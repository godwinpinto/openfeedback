{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-human-verification",
  "type": "registry:component",
  "title": "GenUI Human Verification",
  "description": "GenUI-powered human verification component with automatic text rewriting and tone customization.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/genui-provider.json",
    "dialog",
    "alert",
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/human-verification/genui-human-verification.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { \n  Dialog, \n  DialogContent, \n  DialogHeader, \n  DialogTitle, \n  DialogDescription \n} from '@/components/ui/dialog';\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\nimport { Button } from '@/components/ui/button';\nimport { CheckCircle2, XCircle, Loader2, Camera } from 'lucide-react';\n\n// Type guard for browser environment\nconst isBrowser = typeof window !== 'undefined';\n\nexport interface GenUIHumanVerificationProps {\n  /**\n   * Custom instruction text for the user (if not provided, will be generated using Prompt API)\n   * @default undefined (will be generated)\n   */\n  instruction?: string;\n  \n  /**\n   * Prompt to generate instruction using Prompt API (LanguageModel)\n   * @default \"Write a very short, concise instruction for human verification through selfie, ask them to do some gesture in selfie, gesture should be static. Keep it brief, maximum 20 words.\"\n   */\n  instructionPrompt?: string;\n  \n  /**\n   * Callback when verification succeeds\n   */\n  onVerified?: (confidence: number) => void;\n  \n  /**\n   * Callback when verification fails\n   */\n  onVerificationFailed?: () => void;\n  \n  /**\n   * Callback when an error occurs\n   */\n  onError?: (error: Error) => void;\n  \n  /**\n   * Additional className for the container\n   */\n  className?: string;\n  \n  /**\n   * Custom button text\n   * @default \"Verify you are human\"\n   */\n  buttonText?: string;\n}\n\ntype VerificationState = \n  | 'idle' \n  | 'camera-open' \n  | 'capturing' \n  | 'verifying' \n  | 'verified' \n  | 'failed';\n\ninterface VerificationResult {\n  success: boolean;\n  confidence?: number;\n  reason?: string;\n}\n\nexport const GenUIHumanVerification: React.FC<GenUIHumanVerificationProps> = ({\n  instruction: propInstruction,\n  instructionPrompt = 'Write a very short, concise instruction for human verification through selfie, ask them to do some gesture in selfie, gesture should be static. Keep it brief, maximum 20 words.',\n  onVerified,\n  onVerificationFailed,\n  onError,\n  className,\n  buttonText = 'Verify you are human',\n}) => {\n  const [state, setState] = React.useState<VerificationState>('idle');\n  const [error, setError] = React.useState<string | null>(null);\n  const [verificationResult, setVerificationResult] = React.useState<VerificationResult | null>(null);\n  const [isStreamReady, setIsStreamReady] = React.useState(false);\n  const [generatedInstruction, setGeneratedInstruction] = React.useState<string | null>(null);\n  const [isGeneratingInstruction, setIsGeneratingInstruction] = React.useState(false);\n  \n  // Use prop instruction if provided, otherwise use generated instruction\n  const instruction = propInstruction || generatedInstruction || 'Take your selfie following the instructions below';\n  \n  // Keep instruction ref up to date (always has the latest instruction value)\n  React.useEffect(() => {\n    instructionRef.current = instruction;\n    console.log('[AIHumanVerification] Instruction updated in ref:', instruction);\n  }, [instruction]);\n  \n  const videoRef = React.useRef<HTMLVideoElement>(null);\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const streamRef = React.useRef<MediaStream | null>(null);\n  const sessionRef = React.useRef<any>(null);\n  const instructionRef = React.useRef<string>('');\n\n  // Cleanup function\n  const cleanup = React.useCallback(() => {\n    // Stop camera stream\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    \n    // Destroy language model session\n    if (sessionRef.current) {\n      try {\n        const destroyResult = sessionRef.current.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) {\n        // Ignore destroy errors\n      }\n      sessionRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    return () => {\n      cleanup();\n    };\n  }, [cleanup]);\n\n  const startCamera = React.useCallback(async () => {\n    try {\n      setError(null);\n      \n      // Check if we're in browser environment\n      if (!isBrowser || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Camera access is only available in browser environment.');\n      }\n      \n      setState('camera-open'); // Set state first to show UI\n      \n      // Request camera access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: { \n          facingMode: 'user', // Front-facing camera for selfie\n          width: { ideal: 1280 },\n          height: { ideal: 720 }\n        },\n        audio: false,\n      });\n      \n      streamRef.current = stream;\n      setIsStreamReady(false);\n      \n      // Set video stream and wait for it to be ready\n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        \n        // Wait for video metadata to load\n        await new Promise((resolve) => {\n          if (videoRef.current) {\n            const handleLoadedMetadata = () => {\n              if (videoRef.current) {\n                videoRef.current.removeEventListener('loadedmetadata', handleLoadedMetadata);\n              }\n              resolve(void 0);\n            };\n            videoRef.current.addEventListener('loadedmetadata', handleLoadedMetadata);\n            \n            // Fallback timeout\n            setTimeout(() => {\n              if (videoRef.current) {\n                videoRef.current.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                resolve(void 0);\n              }\n            }, 2000);\n          }\n        });\n        \n        await videoRef.current.play();\n        setIsStreamReady(true);\n      }\n    } catch (err) {\n      const error = err as Error;\n      setError(`Failed to access camera: ${error.message}`);\n      setState('idle');\n      setIsStreamReady(false);\n      cleanup();\n      onError?.(error);\n    }\n  }, [onError, cleanup]);\n\n  const captureImage = React.useCallback(async () => {\n    if (!videoRef.current || !canvasRef.current) {\n      return;\n    }\n\n    try {\n      setState('capturing');\n      \n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      \n      // Set canvas dimensions to match video\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      \n      // Draw video frame to canvas\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Failed to get canvas context');\n      }\n      \n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n      \n      // Stop camera stream\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n      setIsStreamReady(false);\n      \n      // Start verification\n      await verifyImage(canvas);\n    } catch (err) {\n      const error = err as Error;\n      setError(`Failed to capture image: ${error.message}`);\n      setState('idle');\n      cleanup();\n      onError?.(error);\n    }\n  }, [onError, cleanup]);\n\n  const verifyImage = React.useCallback(async (imageCanvas: HTMLCanvasElement) => {\n    try {\n      setState('verifying');\n      setError(null);\n\n      // Check if we're in browser environment\n      if (!isBrowser) {\n        throw new Error('LanguageModel API is only available in browser environment.');\n      }\n\n      // Access global self (which is window in browser)\n      const globalSelf = (typeof self !== 'undefined' ? self : window) as any;\n\n      // Check if LanguageModel is available\n      if (typeof globalSelf.LanguageModel === 'undefined') {\n        throw new Error('Chrome LanguageModel API is not available. Please use Chrome 138+ with required hardware.');\n      }\n\n      // Check availability\n      const availability = await globalSelf.LanguageModel.availability({\n        expectedInputs: [{ type: 'image' }],\n      });\n\n      if (availability === 'unavailable') {\n        throw new Error('LanguageModel is not available on this device. Please check hardware requirements.');\n      }\n\n      // Create session with expectedInputs for image\n      const session = await globalSelf.LanguageModel.create({\n        expectedInputs: [{ type: 'image' }],\n      });\n      \n      sessionRef.current = session;\n\n      // Get the current instruction value from ref (always has the latest value)\n      const currentInstruction = instructionRef.current;\n      \n      console.log('[AIHumanVerification] Using instruction for verification:', currentInstruction);\n      console.log('[AIHumanVerification] Current instruction from ref:', instructionRef.current);\n      console.log('[AIHumanVerification] propInstruction:', propInstruction);\n      console.log('[AIHumanVerification] generatedInstruction:', generatedInstruction);\n      console.log('[AIHumanVerification] computed instruction:', instruction);\n      \n      // Create the prompt with image using the current instruction\n      const promptText = `Does this photo show a person following this instruction: \"${currentInstruction}\"? Analyze the image carefully and respond with a JSON object containing:\n- \"verified\" (true if the person is following the instruction correctly, false otherwise)\n- \"confidence\" (a number between 0 and 1 representing how confident you are in your answer)\n- \"reason\" (if verified is false, provide a brief reason why the verification failed, e.g., \"person is not covering mouth\", \"wrong gesture detected\", etc.)`;\n\n      // Response constraint JSON schema\n      const responseSchema = {\n        type: 'object',\n        properties: {\n          verified: { type: 'boolean' },\n          confidence: { type: 'number', minimum: 0, maximum: 1 },\n          reason: { type: 'string' }, // Optional reason for verification result\n        },\n        required: ['verified', 'confidence'],\n      };\n\n      // Prompt with image using content array format\n      const response = await session.prompt(\n        [\n          {\n            role: 'user',\n            content: [\n              { type: 'text', value: promptText },\n              { type: 'image', value: imageCanvas },\n            ],\n          },\n        ],\n        {\n          responseConstraint: responseSchema,\n        }\n      );\n\n      // Log the raw response for debugging\n      console.log('[AIHumanVerification] Human verification response:', response);\n      \n      // Parse JSON response\n      let result: VerificationResult;\n      try {\n        const parsed = JSON.parse(response);\n        console.log('[AIHumanVerification] Parsed verification result:', parsed);\n        result = {\n          success: parsed.verified === true,\n          confidence: parsed.confidence,\n          reason: parsed.reason,\n        };\n        \n        // Log reason if verification failed\n        if (!result.success && result.reason) {\n          console.log('[AIHumanVerification] Verification failed reason:', result.reason);\n        }\n      } catch (parseError) {\n        // If parsing fails, try to extract from text response\n        console.warn('[AIHumanVerification] Failed to parse JSON, attempting text extraction');\n        const lowerResponse = response.toLowerCase();\n        const hasYes = lowerResponse.includes('yes') || lowerResponse.includes('true');\n        const hasConfidence = /confidence[\\s:]*([\\d.]+)/i.exec(response);\n        \n        // Try to extract reason from text\n        const reasonMatch = /reason[:\\s]+([^.]+)/i.exec(response);\n        const extractedReason = reasonMatch ? reasonMatch[1].trim() : undefined;\n        \n        result = {\n          success: hasYes,\n          confidence: hasConfidence ? parseFloat(hasConfidence[1]) : 0.5,\n          reason: extractedReason,\n        };\n        console.log('[AIHumanVerification] Extracted result from text:', result);\n        \n        // Log reason if verification failed\n        if (!result.success && result.reason) {\n          console.log('[AIHumanVerification] Verification failed reason:', result.reason);\n        }\n      }\n\n      setVerificationResult(result);\n      \n      if (result.success) {\n        setState('verified');\n        onVerified?.(result.confidence || 0);\n      } else {\n        setState('failed');\n        onVerificationFailed?.();\n      }\n\n      // Cleanup session\n      try {\n        const destroyResult = session.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) {\n        // Ignore destroy errors\n      }\n      sessionRef.current = null;\n    } catch (err) {\n      const error = err as Error;\n      setError(`Verification failed: ${error.message}`);\n      setState('failed');\n      cleanup();\n      onError?.(error);\n    }\n  }, [onVerified, onVerificationFailed, onError, cleanup]); // No need for instruction in deps since we use ref\n\n  // Generate instruction using Prompt API (LanguageModel)\n  const generateInstruction = React.useCallback(async () => {\n    // If prop instruction is provided, skip generation\n    if (propInstruction) {\n      return;\n    }\n\n    try {\n      setIsGeneratingInstruction(true);\n      setError(null);\n      \n      // Check if we're in browser environment\n      if (!isBrowser) {\n        throw new Error('LanguageModel API is only available in browser environment.');\n      }\n\n      // Access global self (which is window in browser)\n      const globalSelf = (typeof self !== 'undefined' ? self : window) as any;\n\n      // Check if LanguageModel is available\n      if (typeof globalSelf.LanguageModel === 'undefined') {\n        throw new Error('Chrome LanguageModel API is not available. Please use Chrome 138+ with required hardware.');\n      }\n\n      // Check availability\n      const availability = await globalSelf.LanguageModel.availability();\n      if (availability === 'unavailable') {\n        throw new Error('LanguageModel is not available on this device. Please check hardware requirements.');\n      }\n\n      console.log('[AIHumanVerification] Generating instruction with prompt:', instructionPrompt);\n      \n      // Create session for instruction generation\n      const session = await globalSelf.LanguageModel.create();\n      \n      // Create prompt with constraint to keep it short\n      const fullPrompt = `${instructionPrompt}\n\nRespond with only the instruction text, no extra explanations or formatting. Maximum 15 words.`;\n      \n      const generated = await session.prompt(fullPrompt);\n      \n      console.log('[AIHumanVerification] Prompt API response:', generated);\n      \n      // Clean up the response - extract just the essential instruction\n      let cleaned = generated.trim();\n      \n      console.log('[AIHumanVerification] Raw generated instruction:', cleaned);\n      \n      // Remove markdown formatting\n      cleaned = cleaned.replace(/\\*\\*/g, ''); // Remove bold\n      cleaned = cleaned.replace(/^#+\\s*/gm, ''); // Remove headings\n      cleaned = cleaned.replace(/^\\d+\\.\\s*/gm, ''); // Remove numbered lists\n      cleaned = cleaned.replace(/^[-*]\\s*/gm, ''); // Remove bullet points\n      \n      // Remove quotes if present at the start/end\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, '');\n      \n      // Split into sentences\n      const sentences = cleaned.split(/([.!?]+)/).filter((s: string) => s.trim().length > 0);\n      \n      // Reconstruct sentences with their punctuation\n      let reconstructed: string[] = [];\n      for (let i = 0; i < sentences.length; i += 2) {\n        if (sentences[i]) {\n          const sentence = sentences[i].trim();\n          const punctuation = sentences[i + 1] || '';\n          if (sentence.length > 0) {\n            reconstructed.push(sentence + punctuation);\n          }\n        }\n      }\n      \n      // Take up to 20 words total across sentences, but prefer keeping complete sentences\n      let result = '';\n      let wordCount = 0;\n      const maxWords = 20;\n      \n      for (const sentence of reconstructed) {\n        const sentenceWords = sentence.split(/\\s+/).length;\n        if (wordCount + sentenceWords <= maxWords) {\n          result += (result ? ' ' : '') + sentence;\n          wordCount += sentenceWords;\n        } else {\n          // If we can't fit the full sentence, truncate at word boundary\n          const remainingWords = maxWords - wordCount;\n          if (remainingWords > 0) {\n            const words = sentence.split(/\\s+/).slice(0, remainingWords);\n            result += (result ? ' ' : '') + words.join(' ');\n          }\n          break;\n        }\n      }\n      \n      cleaned = result.trim();\n      \n      // If we got nothing, fall back to first 20 words of original\n      if (!cleaned) {\n        const words = generated.trim().split(/\\s+/).slice(0, 20);\n        cleaned = words.join(' ');\n      }\n      \n      // Ensure it ends with proper punctuation or add period\n      if (!cleaned.match(/[.!?]$/)) {\n        cleaned = cleaned + '.';\n      }\n      \n      console.log('[AIHumanVerification] Cleaned instruction:', cleaned);\n      \n      // Destroy session\n      try {\n        const destroyResult = session.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) {\n        // Ignore destroy errors\n      }\n      \n      setGeneratedInstruction(cleaned);\n    } catch (err) {\n      const error = err as Error;\n      console.error('[AIHumanVerification] Failed to generate instruction:', error);\n      // Fallback to default instruction if generation fails\n      setGeneratedInstruction('take your selfie with your hand covering your mouth');\n      setError(`Failed to generate instruction: ${error.message}`);\n      onError?.(error);\n    } finally {\n      setIsGeneratingInstruction(false);\n    }\n  }, [propInstruction, instructionPrompt, onError]);\n\n  const handleStart = React.useCallback(async () => {\n    setState('idle');\n    setError(null);\n    setVerificationResult(null);\n    setIsStreamReady(false);\n    \n    // Generate instruction first if not provided\n    if (!propInstruction) {\n      await generateInstruction();\n    }\n    \n    startCamera();\n  }, [startCamera, propInstruction, generateInstruction]);\n\n  const handleRetry = React.useCallback(() => {\n    cleanup();\n    setState('idle');\n    setError(null);\n    setVerificationResult(null);\n    setIsStreamReady(false);\n  }, [cleanup]);\n\n  // Create hidden canvas for image capture\n  React.useEffect(() => {\n    if (!canvasRef.current) {\n      const canvas = document.createElement('canvas');\n      canvas.style.display = 'none';\n      canvasRef.current = canvas;\n    }\n  }, []);\n\n  return (\n    <div className={className} style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }}>\n      {/* Hidden canvas for image capture */}\n      <canvas ref={canvasRef} style={{ display: 'none' }} />\n\n      {state === 'idle' && (\n        <div className=\"text-center space-y-4\">\n          <Button\n            onClick={handleStart}\n            disabled={isGeneratingInstruction}\n            size=\"lg\"\n            className=\"min-w-[200px]\"\n          >\n            {isGeneratingInstruction ? (\n              <>\n                <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                Generating instruction...\n              </>\n            ) : (\n              buttonText\n            )}\n          </Button>\n          {error && (\n            <Alert variant=\"destructive\" className=\"mt-4\">\n              <XCircle className=\"w-4 h-4\" />\n              <AlertTitle>Error</AlertTitle>\n              <AlertDescription>{error}</AlertDescription>\n            </Alert>\n          )}\n        </div>\n      )}\n\n      <Dialog open={state === 'camera-open'} onOpenChange={(open) => {\n        if (!open) {\n          cleanup();\n          setState('idle');\n        }\n      }}>\n        <DialogContent className=\"sm:max-w-[600px]\" showCloseButton={false}>\n          <DialogHeader>\n            <DialogTitle>Take Your Selfie</DialogTitle>\n            <DialogDescription>\n              Follow the instruction below to verify you are human\n            </DialogDescription>\n          </DialogHeader>\n          \n          <div className=\"space-y-4\">\n            <div \n              className=\"relative w-full bg-black rounded-lg overflow-hidden\"\n              style={{ \n                minHeight: '400px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              }}\n            >\n              <video\n                ref={videoRef}\n                autoPlay\n                playsInline\n                muted\n                className=\"w-full h-full object-cover block\"\n              />\n              {!isStreamReady && (\n                <div className=\"absolute inset-0 flex items-center justify-center\">\n                  <div className=\"flex flex-col items-center gap-3 text-white\">\n                    <Loader2 className=\"w-8 h-8 animate-spin\" />\n                    <span className=\"text-base\">Loading camera...</span>\n                  </div>\n                </div>\n              )}\n              <div\n                className=\"absolute bottom-4 left-4 right-4 bg-black/75 text-white p-3 rounded-lg text-sm text-center font-medium\"\n              >\n                {instruction}\n              </div>\n            </div>\n            \n            <div className=\"flex gap-3 justify-center\">\n              <Button\n                onClick={captureImage}\n                disabled={!isStreamReady || !streamRef.current}\n                size=\"lg\"\n                className=\"min-w-[140px]\"\n              >\n                <Camera className=\"w-4 h-4 mr-2\" />\n                Capture Selfie\n              </Button>\n              <Button\n                onClick={() => {\n                  cleanup();\n                  setState('idle');\n                }}\n                variant=\"outline\"\n                size=\"lg\"\n                className=\"min-w-[140px]\"\n              >\n                Cancel\n              </Button>\n            </div>\n          </div>\n        </DialogContent>\n      </Dialog>\n\n      {state === 'verifying' && (\n        <div className=\"flex flex-col items-center justify-center py-12 gap-4\">\n          <Loader2 className=\"w-12 h-12 animate-spin text-primary\" />\n          <div className=\"text-lg font-semibold\">Verifying...</div>\n          <div className=\"text-sm text-muted-foreground\">Analyzing your selfie</div>\n        </div>\n      )}\n\n      {state === 'verified' && verificationResult && (\n        <Alert className=\"border-green-500 bg-green-50 dark:bg-green-950\">\n          <CheckCircle2 className=\"w-5 h-5 text-green-600 dark:text-green-400\" />\n          <AlertTitle className=\"text-green-800 dark:text-green-200 font-semibold text-lg\">\n            Verification Successful!\n          </AlertTitle>\n          <AlertDescription className=\"text-green-700 dark:text-green-300 mt-2\">\n            <div className=\"space-y-2\">\n              <p>You have been successfully verified as human.</p>\n              {verificationResult.confidence !== undefined && (\n                <p className=\"text-sm font-medium\">\n                  Confidence: {(verificationResult.confidence * 100).toFixed(1)}%\n                </p>\n              )}\n            </div>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {state === 'failed' && (\n        <Alert variant=\"destructive\">\n          <XCircle className=\"w-5 h-5\" />\n          <AlertTitle className=\"font-semibold text-lg\">Verification Failed</AlertTitle>\n          <AlertDescription className=\"mt-2\">\n            <div className=\"space-y-4\">\n              {error && (\n                <p className=\"text-sm\">{error}</p>\n              )}\n              {!error && (\n                <p>Please make sure you follow the instruction correctly and try again.</p>\n              )}\n              <Button onClick={handleRetry} className=\"mt-2\">\n                Try Again\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};\n",
      "type": "registry:component"
    }
  ]
}