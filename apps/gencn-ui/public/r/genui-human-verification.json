{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-human-verification",
  "type": "registry:component",
  "title": "GenUI Human Verification",
  "description": "GenUI-powered human verification component with automatic text rewriting and tone customization.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/genui-provider.json",
    "dialog",
    "alert",
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/human-verification/genui-human-verification.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { \n  Dialog, \n  DialogContent, \n  DialogHeader, \n  DialogTitle, \n  DialogDescription \n} from '@/components/ui/dialog';\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\nimport { Button } from '@/components/ui/button';\nimport { CheckCircle2, XCircle, Loader2, Camera, Info } from 'lucide-react';\n\n// Type guard for browser environment\nconst isBrowser = typeof window !== 'undefined';\n\nexport interface GenUIHumanVerificationProps {\n  /**\n   * Custom instruction text for the user (if not provided, will be generated using Prompt API)\n   * @default undefined (will be generated)\n   */\n  instruction?: string;\n  \n  /**\n   * Prompt to generate instruction using Prompt API (LanguageModel)\n   * @default \"Write a very short, concise instruction for human verification through selfie, ask them to do some gesture in selfie, gesture should be static. Keep it brief, maximum 20 words.\"\n   */\n  instructionPrompt?: string;\n  \n  /**\n   * Callback when verification succeeds\n   */\n  onVerified?: (confidence: number) => void;\n  \n  /**\n   * Callback when verification fails\n   */\n  onVerificationFailed?: () => void;\n  \n  /**\n   * Callback when an error occurs\n   */\n  onError?: (error: Error) => void;\n  \n  /**\n   * Additional className for the container\n   */\n  className?: string;\n  \n  /**\n   * Custom button text\n   * @default \"Verify you are human\"\n   */\n  buttonText?: string;\n}\n\ntype VerificationState = \n  | 'idle'               // Initial state, button visible\n  | 'generating'         // Generating instruction\n  | 'prompting'          // Dialog open, \"Start Camera\" button visible\n  | 'starting-camera'    // \"Start Camera\" clicked, waiting for stream\n  | 'countdown'          // Camera open, 5s timer running\n  | 'verifying'          // Image captured, analysis in progress\n  | 'failed-attempt'     // Verification failed, \"Retry\" button visible\n  | 'success'            // Final success state, dialog closed\n  | 'failed-final';      // Final failed state (max attempts), dialog closed\n\ninterface VerificationResult {\n  success: boolean;\n  confidence?: number;\n  reason?: string;\n}\n\nconst MAX_ATTEMPTS = 3;\n\nexport const GenUIHumanVerification: React.FC<GenUIHumanVerificationProps> = ({\n  instruction: propInstruction,\n  instructionPrompt = 'Write a very short, concise instruction for human verification through selfie, ask them to do some gesture in selfie, gesture should be static. Keep it brief, maximum 20 words.',\n  onVerified,\n  onVerificationFailed,\n  onError,\n  className,\n  buttonText = 'Verify you are human',\n}) => {\n  const [state, setState] = React.useState<VerificationState>('idle');\n  const [isDialogOpen, setIsDialogOpen] = React.useState(false);\n  const [statusMessage, setStatusMessage] = React.useState<string | null>(null);\n  const [lastFailureReason, setLastFailureReason] = React.useState<string | null>(null);\n  const [attemptCount, setAttemptCount] = React.useState(1);\n  const [countdownValue, setCountdownValue] = React.useState<number | null>(null);\n  \n  const [isStreamReady, setIsStreamReady] = React.useState(false);\n  const [generatedInstruction, setGeneratedInstruction] = React.useState<string | null>(null);\n  const [isGeneratingInstruction, setIsGeneratingInstruction] = React.useState(false);\n  \n  // Use prop instruction if provided, otherwise use generated instruction\n  const instruction = propInstruction || generatedInstruction || 'Take your selfie following the instructions below';\n  \n  // Keep instruction ref up to date\n  React.useEffect(() => {\n    instructionRef.current = instruction;\n  }, [instruction]);\n  \n  const videoRef = React.useRef<HTMLVideoElement>(null);\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const streamRef = React.useRef<MediaStream | null>(null);\n  const sessionRef = React.useRef<any>(null);\n  const instructionRef = React.useRef<string>('');\n  const countdownTimerRef = React.useRef<NodeJS.Timeout | null>(null);\n\n  // Cleanup function\n  const fullCleanup = React.useCallback(() => {\n    // Stop camera stream\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    setIsStreamReady(false);\n    \n    // Destroy language model session\n    if (sessionRef.current) {\n      try {\n        const destroyResult = sessionRef.current.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) {\n        // Ignore destroy errors\n      }\n      sessionRef.current = null;\n    }\n    \n    // Clear any pending timer\n    if (countdownTimerRef.current) {\n      clearInterval(countdownTimerRef.current);\n      countdownTimerRef.current = null;\n    }\n    setCountdownValue(null);\n  }, []);\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    return () => {\n      fullCleanup();\n    };\n  }, [fullCleanup]);\n  \n  // Handle dialog open/close\n  const handleOpenChange = React.useCallback((open: boolean) => {\n    if (!open) {\n      fullCleanup();\n      setIsDialogOpen(false);\n      // Only reset to idle if not in a final success/fail state\n      if (state !== 'success' && state !== 'failed-final') {\n        setState('idle');\n      }\n    }\n  }, [fullCleanup, state]);\n  \n  const closeDialogWithDelay = React.useCallback(() => {\n     setTimeout(() => {\n       setIsDialogOpen(false);\n       // The onOpenChange handler will do the full cleanup\n     }, 100);\n  }, []);\n\n  const startCamera = React.useCallback(async () => {\n    if (streamRef.current) {\n      // Camera is already running\n      startCountdown();\n      return;\n    }\n    \n    try {\n      setStatusMessage('Starting camera...');\n      setState('starting-camera');\n      \n      if (!isBrowser || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Camera access is not available in this browser.');\n      }\n      \n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: { \n          facingMode: 'user',\n          width: { ideal: 1280 },\n          height: { ideal: 720 }\n        },\n        audio: false,\n      });\n      \n      streamRef.current = stream;\n      setIsStreamReady(false);\n      \n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        \n        await new Promise<void>((resolve, reject) => {\n          if (!videoRef.current) return reject(new Error('Video ref lost'));\n          const onLoadedMetadata = () => {\n            videoRef.current?.removeEventListener('loadedmetadata', onLoadedMetadata);\n            resolve();\n          };\n          videoRef.current.addEventListener('loadedmetadata', onLoadedMetadata);\n          setTimeout(() => {\n             videoRef.current?.removeEventListener('loadedmetadata', onLoadedMetadata);\n             reject(new Error('Camera metadata timeout'));\n          }, 3000);\n        });\n        \n        await videoRef.current.play();\n        setIsStreamReady(true);\n        startCountdown();\n      }\n    } catch (err) {\n      const error = err as Error;\n      setStatusMessage(`Failed to access camera: ${error.message}`);\n      setState('prompting'); // Go back to \"Start Camera\"\n      setIsStreamReady(false);\n      onError?.(error);\n    }\n  }, [onError]); // Removed startCountdown from deps, it's called internally\n\n  const startCountdown = React.useCallback(() => {\n    if (countdownTimerRef.current) {\n      clearInterval(countdownTimerRef.current);\n    }\n    \n    setState('countdown');\n    setCountdownValue(5);\n    setStatusMessage('Capturing in 5s...');\n\n    countdownTimerRef.current = setInterval(() => {\n      setCountdownValue(prev => {\n        if (prev === null || prev <= 1) {\n          clearInterval(countdownTimerRef.current!);\n          countdownTimerRef.current = null;\n          setStatusMessage('Capturing...');\n          captureAndVerify();\n          return null;\n        }\n        setStatusMessage(`Capturing in ${prev - 1}s...`);\n        return prev - 1;\n      });\n    }, 1000);\n  }, []); // captureAndVerify is stable as it uses refs/setters\n\n  const captureAndVerify = React.useCallback(async () => {\n    if (!videoRef.current || !canvasRef.current) {\n      setStatusMessage('Capture failed: Missing video reference.');\n      setState('failed-attempt');\n      return;\n    }\n\n    try {\n      setState('verifying');\n      setStatusMessage('Verifying...');\n      \n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      \n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      \n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Failed to get canvas context');\n      }\n      \n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n      \n      // Camera stream STAYS running\n      \n      await verifyImage(canvas);\n    } catch (err) {\n      const error = err as Error;\n      setStatusMessage(`Capture error: ${error.message}`);\n      setLastFailureReason(error.message);\n      \n      // Use updater function to get latest count\n      setAttemptCount(prevAttemptCount => {\n        if (prevAttemptCount >= MAX_ATTEMPTS) {\n          setState('failed-final');\n          closeDialogWithDelay();\n          onVerificationFailed?.();\n        } else {\n          setState('failed-attempt');\n        }\n        return prevAttemptCount + 1;\n      });\n      onError?.(error);\n    }\n  }, [onError, onVerificationFailed, closeDialogWithDelay]); // Removed attemptCount, verifyImage\n\n  const verifyImage = React.useCallback(async (imageCanvas: HTMLCanvasElement) => {\n    try {\n      if (!isBrowser) throw new Error('LanguageModel API is only available in browser.');\n\n      const globalSelf = (typeof self !== 'undefined' ? self : window) as any;\n      if (typeof globalSelf.LanguageModel === 'undefined') {\n        throw new Error('Chrome LanguageModel API is not available.');\n      }\n\n      const availability = await globalSelf.LanguageModel.availability({\n        expectedInputs: [{ type: 'image' }],\n      });\n      if (availability === 'unavailable') {\n        throw new Error('LanguageModel is not available on this device.');\n      }\n\n      const session = await globalSelf.LanguageModel.create({\n        expectedInputs: [{ type: 'image' }],\n      });\n      sessionRef.current = session;\n\n      const currentInstruction = instructionRef.current;\n      const promptText = `Does this photo show a person following this instruction: \"${currentInstruction}\"? Analyze the image carefully and respond with a JSON object containing:\n- \"verified\" (true if the person is following the instruction correctly, false otherwise)\n- \"confidence\" (a number between 0 and 1)\n- \"reason\" (if verified is false, provide a brief reason why)`;\n\n      const responseSchema = {\n        type: 'object',\n        properties: {\n          verified: { type: 'boolean' },\n          confidence: { type: 'number', minimum: 0, maximum: 1 },\n          reason: { type: 'string' },\n        },\n        required: ['verified', 'confidence'],\n      };\n\n      const response = await session.prompt(\n        [\n          {\n            role: 'user',\n            content: [\n              { type: 'text', value: promptText },\n              { type: 'image', value: imageCanvas },\n            ],\n          },\n        ],\n        { responseConstraint: responseSchema }\n      );\n\n      let result: VerificationResult;\n      try {\n        const parsed = JSON.parse(response);\n        result = {\n          success: parsed.verified === true,\n          confidence: parsed.confidence,\n          reason: parsed.reason,\n        };\n      } catch (parseError) {\n        // **FIX:** Don't re-throw. Handle parse failure as a verification failure.\n        console.warn('[AIHumanVerification] Failed to parse JSON, treating as failure.');\n        result = {\n          success: false,\n          confidence: 0,\n          reason: 'Failed to parse verification response. Please try again.',\n        };\n      }\n      \n      // Cleanup session\n      try {\n        const destroyResult = session.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) { /* Ignore */ }\n      sessionRef.current = null;\n      \n      // --- Handle Result ---\n      if (result.success) {\n        console.log(`[AIHumanVerification] Success, Confidence: ${result.confidence}`);\n        setState('success');\n        onVerified?.(result.confidence || 0);\n        closeDialogWithDelay();\n      } else {\n        const reason = result.reason || 'Verification failed. Please try again.';\n        setLastFailureReason(reason);\n        setStatusMessage(reason);\n        \n        // Use updater function to get latest count\n        setAttemptCount(prevAttemptCount => {\n          if (prevAttemptCount >= MAX_ATTEMPTS) {\n            setState('failed-final');\n            onVerificationFailed?.();\n            closeDialogWithDelay();\n          } else {\n            setState('failed-attempt');\n          }\n          return prevAttemptCount + 1;\n        });\n      }\n\n    } catch (err) {\n      const error = err as Error;\n      const reason = `Verification error: ${error.message}`;\n      setLastFailureReason(reason);\n      setStatusMessage(reason);\n      \n      // Use updater function to get latest count\n      setAttemptCount(prevAttemptCount => {\n        if (prevAttemptCount >= MAX_ATTEMPTS) {\n          setState('failed-final');\n          onVerificationFailed?.();\n          closeDialogWithDelay();\n        } else {\n          setState('failed-attempt');\n        }\n        return prevAttemptCount + 1;\n      });\n      onError?.(error);\n    }\n  }, [onVerified, onVerificationFailed, onError, closeDialogWithDelay]); // Removed attemptCount\n\n  // Generate instruction\n  const generateInstruction = React.useCallback(async () => {\n    if (propInstruction) return;\n\n    try {\n      setIsGeneratingInstruction(true);\n      if (!isBrowser) throw new Error('LanguageModel API only available in browser.');\n      \n      const globalSelf = (typeof self !== 'undefined' ? self : window) as any;\n      if (typeof globalSelf.LanguageModel === 'undefined') {\n        throw new Error('Chrome LanguageModel API is not available.');\n      }\n      \n      const availability = await globalSelf.LanguageModel.availability();\n      if (availability === 'unavailable') {\n        throw new Error('LanguageModel is not available on this device.');\n      }\n\n      const session = await globalSelf.LanguageModel.create();\n      const fullPrompt = `${instructionPrompt}\\n\\nRespond with only the instruction text. Maximum 15 words.`;\n      \n      const generated = await session.prompt(fullPrompt);\n      \n      // **FIX:** Replaced simple cleanup with robust logic\n      console.log('[AIHumanVerification] Raw generated instruction:', generated);\n          \n      // Remove markdown formatting\n      let cleaned = generated.trim();\n      cleaned = cleaned.replace(/\\*\\*/g, ''); // Remove bold\n      cleaned = cleaned.replace(/^#+\\s*/gm, ''); // Remove headings\n      cleaned = cleaned.replace(/^\\d+\\.\\s*/gm, ''); // Remove numbered lists\n      cleaned = cleaned.replace(/^[-*]\\s*/gm, ''); // Remove bullet points\n      \n      // Remove quotes if present at the start/end\n      cleaned = cleaned.replace(/^[\"']|[\"']$/g, '');\n      \n      // Split into sentences\n      const sentences = cleaned.split(/([.!?]+)/).filter((s: string) => s.trim().length > 0);\n      \n      // Reconstruct sentences with their punctuation\n      let reconstructed: string[] = [];\n      for (let i = 0; i < sentences.length; i += 2) {\n        if (sentences[i]) {\n          const sentence = sentences[i].trim();\n          const punctuation = sentences[i + 1] || '';\n          if (sentence.length > 0) {\n            reconstructed.push(sentence + punctuation);\n          }\n        }\n      }\n      \n      // Take up to 20 words total across sentences, but prefer keeping complete sentences\n      let result = '';\n      let wordCount = 0;\n      const maxWords = 20;\n      \n      for (const sentence of reconstructed) {\n        const sentenceWords = sentence.split(/\\s+/).length;\n        if (wordCount + sentenceWords <= maxWords) {\n          result += (result ? ' ' : '') + sentence;\n          wordCount += sentenceWords;\n        } else {\n          // If we can't fit the full sentence, truncate at word boundary\n          const remainingWords = maxWords - wordCount;\n          if (remainingWords > 0) {\n            const words = sentence.split(/\\s+/).slice(0, remainingWords);\n            result += (result ? ' ' : '') + words.join(' ');\n          }\n          break;\n        }\n      }\n      \n      cleaned = result.trim();\n      \n      // If we got nothing, fall back to first 20 words of original\n      if (!cleaned) {\n        const words = generated.trim().split(/\\s+/).slice(0, 20);\n        cleaned = words.join(' ');\n      }\n      \n      // Ensure it ends with proper punctuation or add period\n      if (!cleaned.match(/[.!?]$/)) {\n        cleaned = cleaned + '.';\n      }\n      \n      console.log('[AIHumanVerification] Cleaned instruction:', cleaned);\n      // **END FIX**\n\n      setGeneratedInstruction(cleaned);\n      \n      try {\n        const destroyResult = session.destroy();\n        if (destroyResult && typeof destroyResult.catch === 'function') {\n          destroyResult.catch(() => {});\n        }\n      } catch (err) { /* Ignore */ }\n      \n    } catch (err) {\n      const error = err as Error;\n      console.error('[AIHumanVerification] Failed to generate instruction:', error);\n      setGeneratedInstruction('take your selfie with your hand covering your mouth.');\n      onError?.(error);\n    } finally {\n      setIsGeneratingInstruction(false);\n    }\n  }, [propInstruction, instructionPrompt, onError]);\n\n  // Main button click handler\n  const handleStart = React.useCallback(async () => {\n    setState('generating');\n    setLastFailureReason(null);\n    setStatusMessage(null);\n    \n    if (!propInstruction) {\n      await generateInstruction();\n    }\n    \n    setAttemptCount(1); // Reset attempt count\n    setState('prompting');\n    setIsDialogOpen(true);\n  }, [propInstruction, generateInstruction]);\n\n  // Retry button click handler\n  const handleRetry = React.useCallback(() => {\n    // Note: The logic in verifyImage/captureAndVerify already increments the count\n    // We just need to start the countdown for the *next* attempt.\n    startCountdown();\n  }, [startCountdown]);\n\n  // Create hidden canvas on mount\n  React.useEffect(() => {\n    if (!canvasRef.current) {\n      const canvas = document.createElement('canvas');\n      canvas.style.display = 'none';\n      canvasRef.current = canvas;\n    }\n  }, []);\n  \n  // **FIX:** Simplified `useCallback` dependencies\n  // By using `setAttemptCount(prev => ...)` inside the fail handlers,\n  // we no longer need to pass `attemptCount` as a dependency to\n  // `verifyImage` or `captureAndVerify`. This breaks the stale closure chain\n  // and makes the callbacks more stable.\n  React.useEffect(() => {\n    startCountdownRef.current = () => {\n      if (countdownTimerRef.current) {\n        clearInterval(countdownTimerRef.current);\n      }\n      \n      setState('countdown');\n      setCountdownValue(5);\n      setStatusMessage('Capturing in 5s...');\n  \n      countdownTimerRef.current = setInterval(() => {\n        setCountdownValue(prev => {\n          if (prev === null || prev <= 1) {\n            clearInterval(countdownTimerRef.current!);\n            countdownTimerRef.current = null;\n            setStatusMessage('Capturing...');\n            captureAndVerifyRef.current(); // Use ref\n            return null;\n          }\n          setStatusMessage(`Capturing in ${prev - 1}s...`);\n          return prev - 1;\n        });\n      }, 1000);\n    };\n  }, []); // Empty dep array\n\n  const captureAndVerifyRef = React.useRef(captureAndVerify);\n  const startCountdownRef = React.useRef(startCountdown);\n\n  React.useEffect(() => {\n    captureAndVerifyRef.current = captureAndVerify;\n    startCountdownRef.current = startCountdown;\n  });\n\n\n  // --- Render Status Bar ---\n  const renderStatus = () => {\n    switch (state) {\n      case 'starting-camera':\n        return <><Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> {statusMessage}</>;\n      case 'countdown':\n        return <><Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> {statusMessage}</>;\n      case 'verifying':\n        return <><Loader2 className=\"w-4 h-4 mr-2 animate-spin\" /> {statusMessage}</>;\n      case 'failed-attempt':\n        return <><XCircle className=\"w-4 h-4 mr-2 text-destructive\" /> {statusMessage}</>;\n      case 'prompting':\n        return <><Info className=\"w-4 h-4 mr-2 text-blue-500\" /> Ready to start verification.</>;\n      default:\n        return null;\n    }\n  };\n\n  // --- Render Buttons ---\n  const renderButtons = () => {\n    switch (state) {\n      case 'prompting':\n        return (\n          <>\n            <Button onClick={() => setIsDialogOpen(false)} variant=\"outline\">Cancel</Button>\n            <Button onClick={startCamera} size=\"lg\">\n              <Camera className=\"w-4 h-4 mr-2\" />\n              Start Camera\n            </Button>\n          </>\n        );\n      case 'starting-camera':\n        return (\n          <>\n            <Button onClick={() => setIsDialogOpen(false)} variant=\"outline\">Cancel</Button>\n            <Button disabled size=\"lg\">\n              <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n              Starting...\n            </Button>\n          </>\n        );\n      case 'failed-attempt':\n        return (\n          <>\n            <Button onClick={() => setIsDialogOpen(false)} variant=\"outline\">Cancel</Button>\n            {/* Displaying the \"next\" attempt number.\n              After attempt 1 fails, attemptCount is set to 2.\n              Button shows \"Retry Attempt (2/3)\". This is correct.\n            */}\n            <Button onClick={handleRetry} size=\"lg\">\n              Retry\n            </Button>\n          </>\n        );\n      case 'countdown':\n      case 'verifying':\n        return (\n          <p className=\"text-sm text-muted-foreground text-center w-full\">\n            Verification in progress...\n          </p>\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className={className} style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }}>\n      {/* Hidden canvas for image capture */}\n      <canvas ref={canvasRef} style={{ display: 'none' }} />\n\n      {(state === 'idle' || state === 'generating') && (\n        <div className=\"text-center space-y-4\">\n          <Button\n            onClick={handleStart}\n            disabled={state === 'generating'}\n            size=\"lg\"\n            className=\"min-w-[200px]\"\n          >\n            {state === 'generating' ? (\n              <>\n                <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                Please wait...\n              </>\n            ) : (\n              buttonText\n            )}\n          </Button>\n        </div>\n      )}\n\n      {state === 'success' && (\n        <Alert className=\"border-green-500 bg-green-50 dark:bg-green-950\">\n          <CheckCircle2 className=\"w-5 h-5 text-green-600 dark:text-green-400\" />\n          <AlertTitle className=\"text-green-800 dark:text-green-200 font-semibold text-lg\">\n            Verification Successful!\n          </AlertTitle>\n          <AlertDescription className=\"text-green-700 dark:text-green-300 mt-2\">\n            You have been successfully verified as human.\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {state === 'failed-final' && (\n        <Alert variant=\"destructive\">\n          <XCircle className=\"w-5 h-5\" />\n          <AlertTitle className=\"font-semibold text-lg\">Verification Failed</AlertTitle>\n          <AlertDescription className=\"mt-2\">\n            <p>We could not verify you</p>\n            {lastFailureReason && (\n              <p className=\"text-sm mt-2\">\n                <strong>Reason:</strong> {lastFailureReason}\n              </p>\n            )}\n          </AlertDescription>\n        </Alert>\n      )}\n\n      <Dialog open={isDialogOpen} onOpenChange={handleOpenChange}>\n        <DialogContent className=\"sm:max-w-[600px] p-0\" showCloseButton={true}>\n          <DialogHeader className=\"p-6 pb-2\">\n            <DialogTitle>Human Verification</DialogTitle>\n          </DialogHeader>\n          \n          <div className=\"space-y-4 px-6\">\n            {/* Status Bar */}\n            <div className=\"text-sm font-medium h-6 flex items-center text-muted-foreground\">\n              {renderStatus()}\n            </div>\n          \n            {/* Instruction */}\n            <Alert variant=\"default\" className=\"bg-blue-50 border-blue-200 dark:bg-blue-950 dark:border-blue-800\">\n              <Info className=\"w-4 h-4 text-blue-600 dark:text-blue-400\" />\n              <AlertTitle className=\"font-semibold text-blue-800 dark:text-blue-200\">\n                Follow this instruction:\n              </AlertTitle>\n              <AlertDescription className=\"text-blue-700 dark:text-blue-300\">\n                {instruction}\n              </AlertDescription>\n            </Alert>\n          \n            {/* Camera Viewport */}\n            <div \n              className=\"relative w-full bg-black rounded-lg overflow-hidden\"\n              style={{ \n                minHeight: '320px',\n                aspectRatio: '16/9',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              }}\n            >\n              <video\n                ref={videoRef}\n                autoPlay\n                playsInline\n                muted\n                className=\"w-full h-full object-cover block\"\n                style={{ display: isStreamReady ? 'block' : 'none' }}\n              />\n              {(!isStreamReady && state !== 'prompting') && (\n                <div className=\"absolute inset-0 flex items-center justify-center\">\n                  <div className=\"flex flex-col items-center gap-3 text-white\">\n                    <Loader2 className=\"w-8 h-8 animate-spin\" />\n                    <span className=\"text-base\">Loading camera...</span>\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n          \n          {/* Footer / Buttons */}\n          <div className=\"flex gap-3 justify-end p-6 bg-muted/50 rounded-b-lg\">\n            {renderButtons()}\n          </div>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n};",
      "type": "registry:component"
    }
  ]
}