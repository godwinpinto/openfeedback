{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sonner",
  "type": "registry:lib",
  "title": "AI Sonner",
  "description": "AI-powered toast notifications using Sonner with automatic text rewriting and tone customization.",
  "dependencies": [
    "sonner",
    "react"
  ],
  "registryDependencies": [
    "rewriter",
    "gui-provider",
    "summarize-selection"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/toast/lib/sonner.ts",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { toast, type ExternalToast } from 'sonner';\nimport { rewriteOnce } from '@/registry/new-york/gencn-ui/items/shared/lib/rewriter';\n\nexport type AITone =\n  | 'friendly'\n  | 'funny'\n  | 'sarcastic'\n  | 'rude'\n  | 'dramatic'\n  | 'professional'\n  | 'cheerful'\n  | 'empathetic'\n  | 'concise'\n  | 'motivational';\n\nexport const AISONNER_TONES: AITone[] = [\n  'friendly',\n  'funny',\n  'sarcastic',\n  'rude',\n  'dramatic',\n  'professional',\n  'cheerful',\n  'empathetic',\n  'concise',\n  'motivational',\n];\n\nexport type AISONNEROptions = ExternalToast & {\n  tone?: AITone;\n  maxLength?: number;\n  retryOnFail?: boolean;\n};\n\nasync function rewriteIfString(\n  input: React.ReactNode,\n  tone?: AITone,\n  maxLength?: number,\n  retryOnFail: boolean = true\n): Promise<React.ReactNode> {\n  if (typeof input !== 'string') return input;\n\n  const text = input as string;\n  const toneInstruction = tone\n    ? `Rephrase the following text in a ${tone} tone while preserving intent.`\n    : 'Rephrase the following text to improve clarity while preserving intent.';\n\n  const lengthInstruction = typeof maxLength === 'number' && maxLength > 0\n    ? ` Keep it under ${maxLength} characters.`\n    : '';\n\n  const context = `${toneInstruction}${lengthInstruction} Respond with only the rewritten text, no quotes.`;\n\n  try {\n    const rewritten = await rewriteOnce(text, { context });\n    return rewritten || text;\n  } catch (err) {\n    if (retryOnFail) return text;\n    throw err;\n  }\n}\n\nfunction isExternalToastOptions(opts?: ExternalToast | AISONNEROptions): opts is AISONNEROptions {\n  return !!opts;\n}\n\nexport async function aiToast(message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast(rewritten, options);\n}\n\naiToast.success = async function (message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast.success(rewritten, options);\n};\n\naiToast.error = async function (message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast.error(rewritten, options);\n};\n\naiToast.info = async function (message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast.info(rewritten, options);\n};\n\naiToast.warning = async function (message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast.warning(rewritten, options);\n};\n\naiToast.message = async function (message: React.ReactNode, options?: AISONNEROptions) {\n  const rewritten = await rewriteIfString(message, options?.tone, options?.maxLength, options?.retryOnFail !== false);\n  return toast.message(rewritten as any, options as any);\n};\n\naiToast.loading = function (message: React.ReactNode, options?: AISONNEROptions) {\n  // For loading, show immediately; do not wait for rewriting to avoid UX delay.\n  return toast.loading(message, options);\n};\n\naiToast.custom = function (renderer: Parameters<typeof toast.custom>[0], options?: ExternalToast) {\n  return toast.custom(renderer, options);\n};\n\naiToast.dismiss = function (toastId?: number | string) {\n  return toast.dismiss(toastId as any);\n};\n\naiToast.promise = async function <T>(\n  promise: Promise<T>,\n  cfg: {\n    loading: React.ReactNode;\n    success: React.ReactNode | ((value: T) => React.ReactNode);\n    error: React.ReactNode | ((error: any) => React.ReactNode);\n    tone?: AITone;\n    maxLength?: number;\n    retryOnFail?: boolean;\n  },\n  options?: AISONNEROptions\n) {\n  // Show loading immediately (without waiting for rewrite)\n  const id = toast.loading(cfg.loading, options);\n\n  try {\n    const value = await promise;\n    const successContent = typeof cfg.success === 'function' ? cfg.success(value) : cfg.success;\n    const rewritten = await rewriteIfString(successContent, cfg.tone ?? options?.tone, cfg.maxLength ?? options?.maxLength, (cfg.retryOnFail ?? options?.retryOnFail) !== false);\n    return toast.success(rewritten, { ...options, id });\n  } catch (error) {\n    const errorContent = typeof cfg.error === 'function' ? cfg.error(error) : cfg.error;\n    const rewritten = await rewriteIfString(errorContent, cfg.tone ?? options?.tone, cfg.maxLength ?? options?.maxLength, (cfg.retryOnFail ?? options?.retryOnFail) !== false);\n    return toast.error(rewritten, { ...options, id });\n  }\n};\n\n// Re-export Toaster passthrough for convenience if consumers need to render it.\nexport { Toaster } from 'sonner';\n\nexport type AIToastType = typeof aiToast;\n\n\n",
      "type": "registry:lib"
    }
  ]
}