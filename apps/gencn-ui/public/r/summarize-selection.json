{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "summarize-selection",
  "type": "registry:component",
  "title": "Summarize Selection",
  "description": "Component for summarizing selected text with a floating action button.",
  "dependencies": [
    "react",
    "lucide-react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/use-summarizer.json"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/shared/block/components/SummarizeSelection.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Button } from '@/components/ui/button';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { cn } from '@/lib/utils';\nimport { Sparkles, Repeat2 } from 'lucide-react';\nimport { type UseSummarizerOptions, ButtonPosition, SummarizeSelectionProps } from '@/registry/new-york/gencn-ui/items/shared/block/lib/gui-types';\nimport { useSummarizer } from '@/registry/new-york/gencn-ui/items/shared/hooks/useSummarizer';\n\n\n\nexport function SummarizeSelection({ className, defaultOptions, dialogTitle = 'Summary' }: SummarizeSelectionProps) {\n  const [selectionText, setSelectionText] = React.useState<string>('');\n  const [position, setPosition] = React.useState<ButtonPosition>({ top: 0, left: 0, visible: false });\n  const [open, setOpen] = React.useState(false);\n  const debounceRef = React.useRef<number | null>(null);\n  const rangeRef = React.useRef<Range | null>(null);\n  const isSelectionReversedRef = React.useRef<boolean>(false);\n\n  const { isLoading, error, result, runStreaming, run, reset } = useSummarizer({\n    ...defaultOptions,\n  } as UseSummarizerOptions);\n\n  const clearPosition = React.useCallback(() => {\n    setPosition((p) => ({ ...p, visible: false }));\n  }, []);\n\n  const getTargetRect = React.useCallback((range: Range): DOMRect | null => {\n    const rects = range.getClientRects();\n    if (!rects || rects.length === 0) return range.getBoundingClientRect();\n    // For reversed selections (bottom to top), use the first rect\n    // For normal selections (top to bottom), use the last rect\n    if (isSelectionReversedRef.current) {\n      for (let i = 0; i < rects.length; i++) {\n        const r = rects[i];\n        if (r && r.width > 0 && r.height > 0) return r as DOMRect;\n      }\n    } else {\n      // Prefer the last non-empty rect for multi-line selections\n      for (let i = rects.length - 1; i >= 0; i--) {\n        const r = rects[i];\n        if (r && r.width > 0 && r.height > 0) return r as DOMRect;\n      }\n    }\n    return range.getBoundingClientRect();\n  }, []);\n\n  const updateFromSelection = React.useCallback(() => {\n    if (open) {\n      clearPosition();\n      return;\n    }\n    const sel = window.getSelection?.();\n    if (!sel || sel.isCollapsed || !sel.rangeCount) {\n      setSelectionText('');\n      clearPosition();\n      rangeRef.current = null;\n      return;\n    }\n    const range = sel.getRangeAt(0);\n    const text = sel.toString().trim();\n    if (!text) {\n      setSelectionText('');\n      clearPosition();\n      rangeRef.current = null;\n      return;\n    }\n\n    // Detect selection direction: if anchor comes after focus, selection was made bottom to top\n    const anchorNode = sel.anchorNode;\n    const focusNode = sel.focusNode;\n    let isReversed = false;\n    \n    if (anchorNode && focusNode) {\n      if (anchorNode === focusNode) {\n        // Same node, compare offsets\n        isReversed = sel.anchorOffset > sel.focusOffset;\n      } else {\n        // Different nodes: create ranges at anchor and focus points and compare them\n        const anchorRange = document.createRange();\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        \n        const focusRange = document.createRange();\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n        \n        // Compare which range comes first in document order\n        // If anchor range comes after focus range, selection was reversed (bottom to top)\n        const comparison = anchorRange.compareBoundaryPoints(Range.START_TO_START, focusRange);\n        isReversed = comparison > 0;\n      }\n    }\n    \n    isSelectionReversedRef.current = isReversed;\n\n    rangeRef.current = range.cloneRange();\n    const rect = getTargetRect(rangeRef.current);\n    \n    // If selection is reversed (bottom to top), show button above the selection\n    // If selection is normal (top to bottom), show button below the selection\n    const BUTTON_HEIGHT = 32; // Approximate button height (h-8 = 32px)\n    const SPACING = 6;\n    const top = isReversed \n      ? (rect?.top ?? 0) - BUTTON_HEIGHT - SPACING\n      : (rect?.bottom ?? 0) + SPACING;\n    const left = (rect?.right ?? 0) + 6;\n    setSelectionText(text);\n    setPosition({ top, left, visible: true });\n  }, [clearPosition, getTargetRect, open]);\n\n  const debouncedUpdate = React.useCallback(() => {\n    if (debounceRef.current) window.clearTimeout(debounceRef.current);\n    debounceRef.current = window.setTimeout(updateFromSelection, 100);\n  }, [updateFromSelection]);\n\n  React.useEffect(() => {\n    const onSelectionChange = () => debouncedUpdate();\n    document.addEventListener('selectionchange', onSelectionChange);\n    const onScrollOrResize = () => {\n      if (open) return;\n      if (rangeRef.current) {\n        const rect = getTargetRect(rangeRef.current);\n        const BUTTON_HEIGHT = 32; // Approximate button height (h-8 = 32px)\n        const SPACING = 6;\n        const isReversed = isSelectionReversedRef.current;\n        const top = isReversed \n          ? (rect?.top ?? 0) - BUTTON_HEIGHT - SPACING\n          : (rect?.bottom ?? 0) + SPACING;\n        const left = (rect?.right ?? 0) + 6;\n        setPosition((p) => ({ ...p, top, left }));\n      }\n    };\n    window.addEventListener('scroll', onScrollOrResize, true);\n    window.addEventListener('resize', onScrollOrResize, true);\n    return () => {\n      document.removeEventListener('selectionchange', onSelectionChange);\n      window.removeEventListener('scroll', onScrollOrResize, true);\n      window.removeEventListener('resize', onScrollOrResize, true);\n      if (debounceRef.current) window.clearTimeout(debounceRef.current);\n    };\n  }, [debouncedUpdate, getTargetRect]);\n\n  const handleOpen = React.useCallback(async () => {\n    if (!selectionText) return;\n    setOpen(true);\n    reset();\n    try {\n      // Prefer streaming\n      await runStreaming(selectionText, {});\n    } catch {\n      // Fallback to non-streaming\n      try {\n        await run(selectionText, {});\n      } catch {}\n    }\n  }, [selectionText, runStreaming, run, reset]);\n\n  // Hide the button when dialog opens to avoid overlap\n  React.useEffect(() => {\n    if (open) clearPosition();\n  }, [open, clearPosition]);\n\n  return (\n    <>\n      {!open && position.visible && (\n        <div\n          className={cn('fixed z-50', className)}\n          style={{ top: position.top, left: position.left }}\n        >\n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                type=\"button\"\n                size=\"icon\"\n                variant=\"outline\"\n                className=\"h-8 w-8 rounded-lg shadow\"\n                onMouseDown={(e: React.MouseEvent<HTMLButtonElement>) => e.preventDefault()}\n                onClick={() => void handleOpen()}\n              >\n                <Sparkles className=\"h-4 w-4\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>Summarize selection</TooltipContent>\n          </Tooltip>\n        </div>\n      )}\n\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogContent className=\"sm:max-w-xl\">\n          <DialogHeader>\n            <DialogTitle>{dialogTitle}</DialogTitle>\n          </DialogHeader>\n          {error && (\n            <Alert variant=\"destructive\">\n              <AlertTitle>Error</AlertTitle>\n              <AlertDescription>{error.message}</AlertDescription>\n            </Alert>\n          )}\n          <div className=\"space-y-3\">\n            {isLoading ? (\n              <div className=\"space-y-3\">\n                <Skeleton className=\"h-4 w-3/4\" />\n                <Skeleton className=\"h-4 w-5/6\" />\n                <Skeleton className=\"h-4 w-2/3\" />\n                <Skeleton className=\"h-4 w-4/5\" />\n              </div>\n            ) : (\n              <div className=\"whitespace-pre-wrap\">\n                {result || 'No summary yet.'}\n              </div>\n            )}\n          </div>\n          <div className=\"mt-4 flex justify-end\">\n            <Tooltip>\n              <TooltipTrigger asChild>\n                <Button\n                  type=\"button\"\n                  size=\"sm\"\n                  variant=\"outline\"\n                  onClick={() => void handleOpen()}\n                  disabled={isLoading || !selectionText}\n                >\n                  <Repeat2 className=\"h-4 w-4\" />\n                  Re-Summarize\n                </Button>\n              </TooltipTrigger>\n              <TooltipContent>Resummarize</TooltipContent>\n            </Tooltip>\n          </div>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n\n\n",
      "type": "registry:component"
    }
  ]
}