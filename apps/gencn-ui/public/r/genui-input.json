{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-input",
  "type": "registry:component",
  "title": "GenUI Input",
  "description": "GenUI-powered input component with automatic text rewriting and tone customization.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/genui-provider.json",
    "input",
    "textarea",
    "button",
    "spinner",
    "dropdown-menu",
    "dialog",
    "alert",
    "select",
    "command",
    "popover"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/input/genui-input.tsx",
      "content": "\"use client\";\n// This component is a wrapper around the Shadcn UI Input component that adds AI capabilities.\nimport * as React from \"react\";\nimport { Sparkles, Wand2, Languages, Repeat2, SpellCheck } from \"lucide-react\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { Spinner } from \"@/components/ui/spinner\";\nimport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { Alert, AlertTitle, AlertDescription } from \"@/components/ui/alert\";\nimport {\n  Select,\n  SelectTrigger,\n  SelectValue,\n  SelectContent,\n  SelectItem,\n} from \"@/components/ui/select\";\nimport {\n  Command,\n  CommandList,\n  CommandItem,\n  CommandEmpty,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverAnchor,\n} from \"@/components/ui/popover\";\nimport {\n  type DetectedLanguage,\n  type RewriterOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\nimport { proofreadOnce } from \"@/registry/new-york/gencn-ui/items/shared/lib/proofreader\";\nimport { ensureTranslator } from \"@/registry/new-york/gencn-ui/items/shared/lib/translator\";\nimport {\n  isWriterSupported as svcIsWriterSupported,\n  checkWriterAvailability as svcCheckWriterAvailability,\n  ensureWriter as svcEnsureWriter,\n} from \"@/registry/new-york/gencn-ui/items/shared/lib/writer\";\nimport {\n  isRewriterSupported as svcIsRewriterSupported,\n  checkRewriterAvailability as svcCheckRewriterAvailability,\n  ensureRewriter as svcEnsureRewriter,\n} from \"@/registry/new-york/gencn-ui/items/shared/lib/rewriter\";\nimport { detectLanguages } from \"@/registry/new-york/gencn-ui/items/shared/lib/language-detector\";\n\nexport type ButtonVisibility = \"ALWAYS\" | \"ON_FOCUS\";\n\nexport interface GenUIInputProps extends React.ComponentProps<\"input\"> {\n  buttonVisibility?: ButtonVisibility;\n  buttonContent?: React.ReactNode;\n  containerClassName?: string;\n  buttonClassName?: string;\n\n  features?: Array<\n    \"compose\" | \"improve\" | \"fix-grammar\" | \"translate\" | \"auto-suggest\"\n  >;\n  translateTargets?: string[];\n  translateLanguageMap?: Record<string, string>;\n  placeholderPrompt?: string;\n  writerOptions?: {\n    tone?: \"formal\" | \"neutral\" | \"casual\";\n    format?: \"markdown\" | \"plain-text\";\n    length?: \"short\" | \"medium\" | \"long\";\n    sharedContext?: string;\n    expectedInputLanguages?: string[];\n    expectedContextLanguages?: string[];\n    outputLanguage?: string;\n  };\n  autoSuggestDebounceMs?: number;\n  autoSuggestMinChars?: number;\n  autoSuggestPrompt?: string;\n  onAccept?: (text: string) => void;\n  onAIError?: (error: Error) => void;\n}\n\nexport const GenUIInput = React.forwardRef<HTMLInputElement, GenUIInputProps>(\n  (\n    {\n      buttonVisibility = \"ALWAYS\",\n      buttonContent,\n      containerClassName,\n      buttonClassName,\n      className,\n      onFocus,\n      onBlur,\n      features,\n      translateTargets,\n      translateLanguageMap,\n      placeholderPrompt,\n      writerOptions,\n      autoSuggestDebounceMs = 500,\n      autoSuggestMinChars = 3,\n      autoSuggestPrompt,\n      onAccept,\n      onAIError,\n      ...props\n    },\n    ref\n  ) => {\n    const [isFocused, setIsFocused] = React.useState(false);\n    const [isLoading, setIsLoading] = React.useState(false);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n\n    // Auto-suggest state\n    const [suggestions, setSuggestions] = React.useState<string[]>([]);\n    const [selectedIndex, setSelectedIndex] = React.useState<number>(-1);\n    const [isLoadingSuggestions, setIsLoadingSuggestions] =\n      React.useState(false);\n    const suggestTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n    const suggestAbortRef = React.useRef<AbortController | null>(null);\n    const autoSuggestRewriterRef = React.useRef<any>(null);\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const autoSuggestActive = features?.includes(\"auto-suggest\") ?? false;\n\n    // AI Feature UI state\n    const [isFeatureOpen, setIsFeatureOpen] = React.useState(false);\n    const [activeFeature, setActiveFeature] = React.useState<\n      \"compose\" | \"improve\" | \"fix-grammar\" | \"translate\" | null\n    >(null);\n    const [phase, setPhase] = React.useState<\n      \"prompt\" | \"generating\" | \"result\"\n    >(\"prompt\");\n    const [promptText, setPromptText] = React.useState(\"\");\n    const [resultText, setResultText] = React.useState(\"\");\n    const [aiError, setAiError] = React.useState<string | null>(null);\n    const [downloadProgress, setDownloadProgress] = React.useState<\n      number | null\n    >(null);\n    const [detected, setDetected] = React.useState<DetectedLanguage[] | null>(\n      null\n    );\n    const [selectedTarget, setSelectedTarget] = React.useState<string>(\"\");\n    const abortRef = React.useRef<AbortController | null>(null);\n    const writerRef = React.useRef<any>(null);\n    const rewriterRef = React.useRef<any>(null);\n\n    const isWriterSupported = svcIsWriterSupported();\n    const isRewriterSupported = svcIsRewriterSupported();\n\n    React.useImperativeHandle(\n      ref,\n      () => inputRef.current as HTMLInputElement,\n      []\n    );\n\n    const handleFocus = React.useCallback(\n      (e: React.FocusEvent<HTMLInputElement>) => {\n        setIsFocused(true);\n        onFocus?.(e);\n      },\n      [onFocus]\n    );\n\n    const handleBlur = React.useCallback(\n      (e: React.FocusEvent<HTMLInputElement>) => {\n        setIsFocused(false);\n        // Delay clearing suggestions to allow clicking on them\n        setTimeout(() => {\n          const activeElement = document.activeElement;\n          if (\n            containerRef.current &&\n            !containerRef.current.contains(activeElement)\n          ) {\n            setSuggestions([]);\n            setSelectedIndex(-1);\n          }\n        }, 200);\n        onBlur?.(e);\n      },\n      [onBlur]\n    );\n\n    const ensureWriter = React.useCallback(async () => {\n      try {\n        if (!isWriterSupported) {\n          throw new Error(\"Chrome Writer API is not supported.\");\n        }\n        const avail = await svcCheckWriterAvailability();\n        if (avail === \"unavailable\" || avail === null) {\n          throw new Error(\"Writer API is unavailable on this device.\");\n        }\n        const options = {\n          ...(writerOptions ?? {}),\n          monitor: (m: any) => {\n            m?.addEventListener?.(\"downloadprogress\", (e: any) => {\n              if (typeof e.loaded === \"number\") {\n                setDownloadProgress(Math.round(e.loaded * 100));\n              }\n            });\n          },\n        };\n        writerRef.current = await svcEnsureWriter(options as any);\n        return writerRef.current;\n      } catch (err) {\n        setAiError((err as Error).message);\n        onAIError?.(err as Error);\n        return null;\n      }\n    }, [isWriterSupported, writerOptions, onAIError]);\n\n    const startComposeStreaming = React.useCallback(async () => {\n      setAiError(null);\n      setResultText(\"\");\n      setPhase(\"generating\");\n      setIsLoading(true);\n      try {\n        const writer = writerRef.current ?? (await ensureWriter());\n        if (!writer) {\n          setIsLoading(false);\n          setPhase(\"prompt\");\n          return;\n        }\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n        const stream = writer.writeStreaming(promptText, {\n          signal: abortRef.current.signal,\n          context: writerOptions?.sharedContext,\n        });\n        let acc = \"\";\n        for await (const chunk of stream) {\n          acc += chunk;\n          setResultText(acc);\n        }\n        setPhase(\"result\");\n      } catch (err) {\n        if ((err as any)?.name !== \"AbortError\") {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          onAIError?.(err as Error);\n          setPhase(\"prompt\");\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [ensureWriter, promptText, writerOptions, onAIError]);\n\n    const closeFeature = React.useCallback(() => {\n      abortRef.current?.abort();\n      abortRef.current = null;\n      setIsFeatureOpen(false);\n      setActiveFeature(null);\n      setPhase(\"prompt\");\n      setPromptText(\"\");\n      setResultText(\"\");\n      setAiError(null);\n      setDownloadProgress(null);\n      setDetected(null);\n    }, []);\n\n    // Improve controls state\n    const [tone, setTone] = React.useState<\n      \"more-formal\" | \"as-is\" | \"more-casual\"\n    >(\"as-is\");\n    const [lengthPref, setLengthPref] = React.useState<\n      \"shorter\" | \"as-is\" | \"longer\"\n    >(\"as-is\");\n    const [formatPref, setFormatPref] = React.useState<\n      \"as-is\" | \"markdown\" | \"plain-text\"\n    >(\"plain-text\");\n    const [contextText, setContextText] = React.useState(\"\");\n\n    const ensureRewriter = React.useCallback(async () => {\n      try {\n        if (!isRewriterSupported) {\n          throw new Error(\"Chrome Rewriter API is not supported.\");\n        }\n        const avail = await svcCheckRewriterAvailability();\n        if (avail === \"unavailable\" || avail === null) {\n          throw new Error(\"Rewriter API is unavailable on this device.\");\n        }\n        const options: RewriterOptions = {\n          tone,\n          length: lengthPref,\n          format: formatPref,\n          monitor: (m: any) => {\n            m?.addEventListener?.(\"downloadprogress\", (e: any) => {\n              if (typeof e.loaded === \"number\") {\n                setDownloadProgress(Math.round(e.loaded * 100));\n              }\n            });\n          },\n        };\n        rewriterRef.current = await svcEnsureRewriter(options as any);\n        return rewriterRef.current;\n      } catch (err) {\n        setAiError((err as Error).message);\n        onAIError?.(err as Error);\n        return null;\n      }\n    }, [isRewriterSupported, tone, lengthPref, formatPref, onAIError]);\n\n    const startImprove = React.useCallback(async () => {\n      setAiError(null);\n      setResultText(\"\");\n      setPhase(\"generating\");\n      setIsLoading(true);\n      try {\n        const text = inputRef.current?.value || \"\";\n        if (!text.trim()) {\n          throw new Error(\"Please enter some text to improve.\");\n        }\n        const rewriter = rewriterRef.current ?? (await ensureRewriter());\n        if (!rewriter) {\n          setIsLoading(false);\n          setPhase(\"prompt\");\n          return;\n        }\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n        if (typeof rewriter.rewriteStreaming === \"function\") {\n          const stream = rewriter.rewriteStreaming(text, {\n            signal: abortRef.current.signal,\n            context: contextText || undefined,\n          });\n          let acc = \"\";\n          for await (const chunk of stream) {\n            acc += chunk;\n            setResultText(acc);\n          }\n          setPhase(\"result\");\n        } else {\n          const result = await rewriter.rewrite(text, {\n            signal: abortRef.current.signal,\n            context: contextText || undefined,\n          });\n          setResultText(result);\n          setPhase(\"result\");\n        }\n      } catch (err) {\n        if ((err as any)?.name === \"AbortError\") {\n          // ignore aborts\n        } else {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          onAIError?.(err as Error);\n          setPhase(\"prompt\");\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [ensureRewriter, contextText, onAIError]);\n\n    React.useEffect(() => {\n      return () => {\n        abortRef.current?.abort();\n        try {\n          writerRef.current?.destroy?.();\n        } catch {}\n      };\n    }, []);\n\n    const openCompose = React.useCallback(() => {\n      setActiveFeature(\"compose\");\n      setIsFeatureOpen(true);\n      setPhase(\"prompt\");\n      setPromptText(\"\");\n      setResultText(\"\");\n      setAiError(null);\n    }, []);\n\n    const openImprove = React.useCallback(() => {\n      setActiveFeature(\"improve\");\n      setIsFeatureOpen(true);\n      setPhase(\"prompt\");\n      setResultText(\"\");\n      setAiError(null);\n      setDownloadProgress(null);\n    }, []);\n\n    const openFixGrammar = React.useCallback(() => {\n      setActiveFeature(\"fix-grammar\");\n      setIsFeatureOpen(true);\n      setPhase(\"generating\");\n      setResultText(\"\");\n      setAiError(null);\n      setDownloadProgress(null);\n      setDetected(null);\n    }, []);\n\n    const openTranslate = React.useCallback(async () => {\n      setActiveFeature(\"translate\");\n      setIsFeatureOpen(true);\n      setPhase(\"prompt\");\n      setResultText(\"\");\n      setAiError(null);\n      setDownloadProgress(null);\n      \n      // Detect language when modal opens\n      const text = inputRef.current?.value || \"\";\n      let detectedSource: string | null = null;\n      if (text.trim()) {\n        try {\n          const detectedLangs = await detectLanguages(text);\n          setDetected(detectedLangs);\n          if (detectedLangs && detectedLangs.length > 0) {\n            detectedSource = detectedLangs[0].detectedLanguage;\n          }\n        } catch {\n          setDetected(null);\n        }\n      } else {\n        setDetected(null);\n      }\n      \n      // Preselect first provided target that is not the detected source language\n      const availableTargets = translateTargets?.filter((code: string) => {\n        return !detectedSource || code !== detectedSource;\n      }) || [];\n      setSelectedTarget(availableTargets[0] || \"\");\n    }, [translateTargets]);\n\n    const startTranslate = React.useCallback(async () => {\n      setAiError(null);\n      setResultText(\"\");\n      setPhase(\"generating\");\n      setIsLoading(true);\n      try {\n        const text = inputRef.current?.value || \"\";\n        if (!text.trim())\n          throw new Error(\"Please enter some text to translate.\");\n        if (!selectedTarget)\n          throw new Error(\"Please select a target language.\");\n        const detectedLangs = await detectLanguages(text);\n        setDetected(detectedLangs);\n        const sourceLanguage =\n          detectedLangs && detectedLangs.length > 0\n            ? detectedLangs[0].detectedLanguage\n            : \"en\";\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n        const translator = await ensureTranslator({\n          sourceLanguage,\n          targetLanguage: selectedTarget,\n          monitor(m: any) {\n            try {\n              m.addEventListener(\"downloadprogress\", (e: any) => {\n                if (typeof e.loaded === \"number\")\n                  setDownloadProgress(Math.round(e.loaded * 100));\n              });\n            } catch {}\n          },\n        } as any);\n        if (typeof (translator as any).translateStreaming === \"function\") {\n          const stream = (translator as any).translateStreaming(text, {\n            signal: abortRef.current.signal,\n          });\n          let acc = \"\";\n          for await (const chunk of stream) {\n            acc += chunk;\n            setResultText(acc);\n          }\n          setPhase(\"result\");\n        } else {\n          const result = await (translator as any).translate(text);\n          setResultText(result);\n          setPhase(\"result\");\n        }\n      } catch (err) {\n        if ((err as any)?.name !== \"AbortError\") {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          setPhase(\"result\");\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [selectedTarget]);\n\n    const startFixGrammar = React.useCallback(async () => {\n      setAiError(null);\n      setIsLoading(true);\n      try {\n        const text = inputRef.current?.value || \"\";\n        if (!text.trim())\n          throw new Error(\"Please enter some text to fix grammar.\");\n        const detectedLangs = await detectLanguages(text);\n        setDetected(detectedLangs);\n        const topLanguage =\n          detectedLangs && detectedLangs.length > 0\n            ? detectedLangs[0].detectedLanguage\n            : \"en\";\n        const res = await proofreadOnce(text, {\n          expectedInputLanguages: [topLanguage],\n          onProgress: (p) => setDownloadProgress(p),\n        });\n        setResultText(res.corrected);\n        setPhase(\"result\");\n      } catch (err) {\n        const msg = (err as Error).message;\n        setAiError(msg);\n        setPhase(\"result\");\n      } finally {\n        setIsLoading(false);\n      }\n    }, []);\n\n    React.useEffect(() => {\n      if (\n        isFeatureOpen &&\n        activeFeature === \"fix-grammar\" &&\n        phase === \"generating\" &&\n        !resultText\n      ) {\n        startFixGrammar();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isFeatureOpen, activeFeature, phase]);\n\n    const acceptResult = React.useCallback(() => {\n      if (inputRef.current) {\n        inputRef.current.value = resultText;\n        const event = new Event(\"input\", { bubbles: true });\n        inputRef.current.dispatchEvent(event);\n      }\n      onAccept?.(resultText);\n      closeFeature();\n    }, [resultText, onAccept, closeFeature]);\n\n    const regen = React.useCallback(() => {\n      setPhase(\"prompt\");\n      setResultText(\"\");\n      setAiError(null);\n    }, []);\n\n    const handleStop = React.useCallback(() => {\n      abortRef.current?.abort();\n      setIsLoading(false);\n      setPhase(\"result\");\n    }, []);\n\n    // Clear suggestions helper\n    const clearSuggestions = React.useCallback(() => {\n      setSuggestions([]);\n      setSelectedIndex(-1);\n      setIsLoadingSuggestions(false);\n      suggestAbortRef.current?.abort();\n      suggestAbortRef.current = null;\n      if (suggestTimeoutRef.current) {\n        clearTimeout(suggestTimeoutRef.current);\n        suggestTimeoutRef.current = null;\n      }\n    }, []);\n\n    // Ensure rewriter for auto-suggest\n    const ensureAutoSuggestRewriter = React.useCallback(async () => {\n      try {\n        if (!isRewriterSupported) {\n          return null;\n        }\n        if (autoSuggestRewriterRef.current) {\n          return autoSuggestRewriterRef.current;\n        }\n        const rewriter = await svcEnsureRewriter({\n          tone: \"as-is\",\n          length: \"as-is\",\n          format: \"plain-text\",\n        });\n        autoSuggestRewriterRef.current = rewriter;\n        return rewriter;\n      } catch (err) {\n        console.error(\"Failed to initialize auto-suggest rewriter:\", err);\n        return null;\n      }\n    }, [isRewriterSupported]);\n\n    // Generate suggestions with uniqueness checking\n    const generateSuggestions = React.useCallback(\n      async (text: string) => {\n        if (\n          !autoSuggestActive ||\n          !text.trim() ||\n          text.trim().length < autoSuggestMinChars\n        ) {\n          clearSuggestions();\n          return;\n        }\n\n        // Debounce: cancel prior\n        if (suggestTimeoutRef.current) {\n          clearTimeout(suggestTimeoutRef.current);\n        }\n\n        suggestTimeoutRef.current = setTimeout(async () => {\n          try {\n            setIsLoadingSuggestions(true);\n            suggestAbortRef.current?.abort();\n            suggestAbortRef.current = new AbortController();\n\n            const rewriter = await ensureAutoSuggestRewriter();\n            if (!rewriter) {\n              clearSuggestions();\n              return;\n            }\n\n            // Use provided prompt or default\n            const prompt =\n              autoSuggestPrompt ||\n              \"Continue from the caret as an autocomplete. Do not change or repeat any existing user text before the caret. If you must return the full text, ensure it begins with the original text exactly and then adds only the natural continuation. No quotes or prefaces. Keep it coherent and concise (about 8–12 words).\";\n\n            // Start with empty suggestions array\n            setSuggestions([]);\n            setSelectedIndex(-1);\n\n            // Track completion count\n            let completedCount = 0;\n            const totalSuggestions = 3;\n\n            // Generate 3 variants in parallel, show them as they arrive\n            [0, 1, 2].forEach(async (index) => {\n              try {\n                let result: string | null = null;\n\n                if (typeof rewriter.rewrite === \"function\") {\n                  result = (await rewriter.rewrite(text, {\n                    context: prompt,\n                    signal: suggestAbortRef.current?.signal,\n                  })) as string;\n                } else if (typeof rewriter.rewriteStreaming === \"function\") {\n                  let acc = \"\";\n                  const stream = rewriter.rewriteStreaming(text, {\n                    context: prompt,\n                    signal: suggestAbortRef.current?.signal,\n                  });\n                  for await (const chunk of stream) {\n                    acc += chunk;\n                  }\n                  result = acc;\n                }\n\n                // Check if request was aborted\n                if (suggestAbortRef.current?.signal.aborted) {\n                  return;\n                }\n\n                // Update suggestions as each one arrives\n                if (result && result.trim().length > 0) {\n                  setSuggestions((prev) => {\n                    // Append the new suggestion to the array\n                    const newSuggestions = [...prev, result!];\n                    // Limit to 3 suggestions max\n                    return newSuggestions.slice(0, 3);\n                  });\n                }\n\n                // Update loading state\n                completedCount++;\n                // Stop loading when all 3 are complete\n                if (completedCount >= totalSuggestions) {\n                  setIsLoadingSuggestions(false);\n                }\n              } catch (err) {\n                if ((err as any)?.name === \"AbortError\") {\n                  return;\n                }\n                console.error(`Error generating suggestion ${index + 1}:`, err);\n\n                // Update completion count even on error\n                completedCount++;\n                // Stop loading when all are complete\n                if (completedCount >= totalSuggestions) {\n                  setIsLoadingSuggestions(false);\n                }\n              }\n            });\n          } catch (err) {\n            if ((err as any)?.name !== \"AbortError\") {\n              // Silent fail for auto-suggest\n              console.error(\"Auto-suggest error:\", err);\n            }\n            clearSuggestions();\n          }\n        }, autoSuggestDebounceMs);\n      },\n      [\n        autoSuggestActive,\n        autoSuggestMinChars,\n        autoSuggestDebounceMs,\n        autoSuggestPrompt,\n        ensureAutoSuggestRewriter,\n        clearSuggestions,\n      ]\n    );\n\n    // Apply selected suggestion\n    const applySuggestion = React.useCallback(\n      (suggestion: string) => {\n        if (inputRef.current) {\n          inputRef.current.value = suggestion;\n          const event = new Event(\"input\", { bubbles: true });\n          inputRef.current.dispatchEvent(event);\n        }\n        clearSuggestions();\n        inputRef.current?.focus();\n      },\n      [clearSuggestions]\n    );\n\n    // Handle input changes\n    const handleInput = React.useCallback(\n      (e: React.FormEvent<HTMLInputElement>) => {\n        const value = e.currentTarget.value;\n        if (autoSuggestActive) {\n          generateSuggestions(value);\n        }\n        props.onInput?.(e);\n      },\n      [autoSuggestActive, generateSuggestions, props]\n    );\n\n    // Handle keyboard navigation\n    const handleKeyDown = React.useCallback(\n      (e: React.KeyboardEvent<HTMLInputElement>) => {\n        if (!autoSuggestActive || suggestions.length === 0) {\n          props.onKeyDown?.(e);\n          return;\n        }\n\n        if (e.key === \"ArrowDown\") {\n          e.preventDefault();\n          setSelectedIndex((prev) =>\n            prev < suggestions.length - 1 ? prev + 1 : 0\n          );\n        } else if (e.key === \"ArrowUp\") {\n          e.preventDefault();\n          setSelectedIndex((prev) =>\n            prev > 0 ? prev - 1 : suggestions.length - 1\n          );\n        } else if (\n          e.key === \"Enter\" &&\n          selectedIndex >= 0 &&\n          selectedIndex < suggestions.length\n        ) {\n          e.preventDefault();\n          applySuggestion(suggestions[selectedIndex]);\n        } else if (e.key === \"Escape\") {\n          e.preventDefault();\n          clearSuggestions();\n        } else {\n          props.onKeyDown?.(e);\n        }\n      },\n      [\n        autoSuggestActive,\n        suggestions,\n        selectedIndex,\n        applySuggestion,\n        clearSuggestions,\n        props,\n      ]\n    );\n\n    // Cleanup on unmount\n    React.useEffect(() => {\n      return () => {\n        clearSuggestions();\n        try {\n          autoSuggestRewriterRef.current?.destroy?.();\n        } catch {}\n        autoSuggestRewriterRef.current = null;\n      };\n    }, [clearSuggestions]);\n\n    const featureIcon = React.useMemo(() => {\n      if (!activeFeature && (features?.length ?? 0) === 1) {\n        const f = features![0];\n        if (f === \"compose\") return <Wand2 className=\"size-4\" />;\n        if (f === \"translate\") return <Languages className=\"size-4\" />;\n        if (f === \"improve\" || f === \"fix-grammar\")\n          return <Repeat2 className=\"size-4\" />;\n      }\n      return <Wand2 className=\"size-4\" />;\n    }, [activeFeature, features]);\n\n    const shouldShowButton =\n      buttonVisibility === \"ALWAYS\" ||\n      (buttonVisibility === \"ON_FOCUS\" && isFocused);\n    const defaultButtonContent = buttonContent ?? (\n      <Sparkles className=\"size-4\" />\n    );\n    const buttonContentWithLoading = isLoading ? (\n      <Spinner className=\"size-4\" />\n    ) : (\n      defaultButtonContent\n    );\n    const hasFeatureUI = Array.isArray(features) && features.length > 0;\n    const showSuggestions =\n      autoSuggestActive && (suggestions.length > 0 || isLoadingSuggestions);\n\n    return (\n      <div ref={containerRef} className={cn(\"relative\", containerClassName)}>\n        <Popover\n          open={showSuggestions}\n          onOpenChange={(open) => {\n            if (!open) {\n              clearSuggestions();\n            }\n          }}\n        >\n          <PopoverAnchor asChild>\n            <Input\n              ref={inputRef}\n              className={cn(\n                className,\n                shouldShowButton && hasFeatureUI && \"pr-12\"\n              )}\n              onFocus={handleFocus}\n              onBlur={handleBlur}\n              onInput={handleInput}\n              onKeyDown={handleKeyDown}\n              {...props}\n            />\n          </PopoverAnchor>\n\n          {/* Auto-suggest dropdown */}\n          {showSuggestions && (\n            <PopoverContent\n              side=\"bottom\"\n              align=\"start\"\n              className=\"w-[var(--radix-popover-trigger-width)] p-0\"\n              onOpenAutoFocus={(e) => e.preventDefault()}\n            >\n              <Command\n                shouldFilter={false}\n                value={\n                  selectedIndex >= 0 && selectedIndex < suggestions.length\n                    ? suggestions[selectedIndex]\n                    : undefined\n                }\n              >\n                <CommandList className=\"max-h-none\">\n                  {isLoadingSuggestions ? (\n                    <CommandEmpty>\n                      <div className=\"flex items-center justify-center py-4\">\n                        <Spinner className=\"size-4 mr-2\" />\n                        <span className=\"text-sm text-muted-foreground\">\n                          Generating suggestions...\n                        </span>\n                      </div>\n                    </CommandEmpty>\n                  ) : suggestions.length > 0 ? (\n                    suggestions.map((suggestion, index) => (\n                      <CommandItem\n                        key={index}\n                        value={suggestion}\n                        onSelect={() => applySuggestion(suggestion)}\n                        className={cn(\n                          \"cursor-pointer\",\n                          selectedIndex === index && \"bg-accent\"\n                        )}\n                        data-selected={selectedIndex === index}\n                      >\n                        <span className=\"text-sm\">{suggestion}</span>\n                      </CommandItem>\n                    ))\n                  ) : null}\n                </CommandList>\n              </Command>\n            </PopoverContent>\n          )}\n        </Popover>\n\n        {shouldShowButton &&\n          hasFeatureUI &&\n          (features!.length === 1 ? (\n            <Button\n              type=\"button\"\n              size=\"icon\"\n              variant=\"ghost\"\n              onClick={() => {\n                if (features![0] === \"compose\") {\n                  openCompose();\n                } else if (features![0] === \"improve\") {\n                  openImprove();\n                } else if (features![0] === \"fix-grammar\") {\n                  openFixGrammar();\n                } else if (features![0] === \"translate\") {\n                  openTranslate();\n                }\n              }}\n              disabled={isLoading}\n              className={cn(\n                \"absolute right-2 top-1/2 -translate-y-1/2 h-7 w-7 rounded-md shadow-sm hover:bg-accent/80 transition-opacity z-10\",\n                isLoading && \"cursor-wait\",\n                buttonClassName\n              )}\n              aria-label=\"AI actions\"\n            >\n              {isLoading ? <Spinner className=\"size-4\" /> : featureIcon}\n            </Button>\n          ) : (\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button\n                  type=\"button\"\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  disabled={isLoading}\n                  className={cn(\n                    \"absolute right-2 top-1/2 -translate-y-1/2 h-7 w-7 rounded-md shadow-sm hover:bg-accent/80 transition-opacity z-10\",\n                    isLoading && \"cursor-wait\",\n                    buttonClassName\n                  )}\n                  aria-label=\"Choose AI action\"\n                >\n                  {isLoading ? (\n                    <Spinner className=\"size-4\" />\n                  ) : (\n                    <Wand2 className=\"size-4\" />\n                  )}\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align=\"end\" className=\"min-w-44\">\n                {features!.includes(\"compose\") && (\n                  <DropdownMenuItem onClick={openCompose}>\n                    <Wand2 className=\"mr-2 h-4 w-4\" /> Compose\n                  </DropdownMenuItem>\n                )}\n                {features!.includes(\"improve\") && (\n                  <DropdownMenuItem onClick={openImprove}>\n                    <Repeat2 className=\"mr-2 h-4 w-4\" /> Improve\n                  </DropdownMenuItem>\n                )}\n                {features!.includes(\"fix-grammar\") && (\n                  <DropdownMenuItem onClick={openFixGrammar}>\n                    <SpellCheck className=\"mr-2 h-4 w-4\" /> Fix grammar\n                  </DropdownMenuItem>\n                )}\n                {features!.includes(\"translate\") && (\n                  <DropdownMenuItem onClick={openTranslate}>\n                    <Languages className=\"mr-2 h-4 w-4\" /> Translate\n                  </DropdownMenuItem>\n                )}\n              </DropdownMenuContent>\n            </DropdownMenu>\n          ))}\n\n        {/* Compose Modal */}\n        <Dialog\n          open={isFeatureOpen && activeFeature === \"compose\"}\n          onOpenChange={(open) => {\n            if (!open) closeFeature();\n          }}\n        >\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Compose with AI</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">\n                Model downloading… {downloadProgress}%\n              </div>\n            )}\n\n            {phase === \"prompt\" && (\n              <div className=\"space-y-3\">\n                <Input\n                  placeholder={placeholderPrompt || \"describe what you want\"}\n                  value={promptText}\n                  onChange={(e) => setPromptText(e.target.value)}\n                />\n              </div>\n            )}\n\n            {phase === \"generating\" && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Generating…\n                </div>\n                {resultText && (\n                  <Textarea\n                    value={resultText}\n                    readOnly\n                    className=\"min-h-[160px]\"\n                  />\n                )}\n              </div>\n            )}\n\n            {phase === \"result\" && (\n              <div className=\"space-y-3\">\n                <Textarea\n                  value={resultText}\n                  readOnly\n                  className=\"min-h-[200px]\"\n                />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === \"prompt\" && (\n                <Button\n                  onClick={startComposeStreaming}\n                  disabled={!promptText.trim() || isLoading}\n                >\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Generate\n                </Button>\n              )}\n              {phase === \"generating\" && (\n                <Button variant=\"outline\" onClick={handleStop}>\n                  Stop\n                </Button>\n              )}\n              {phase === \"result\" && (\n                <>\n                  <Button variant=\"outline\" onClick={regen}>\n                    Regenerate\n                  </Button>\n                  {typeof resultText === \"string\" &&\n                    resultText.trim().length > 0 && (\n                      <Button onClick={acceptResult}>Accept</Button>\n                    )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Fix Grammar Modal */}\n        <Dialog\n          open={isFeatureOpen && activeFeature === \"fix-grammar\"}\n          onOpenChange={(open: boolean) => {\n            if (!open) closeFeature();\n          }}\n        >\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Fix grammar</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {detected && detected.length > 0 && (\n              <div className=\"mb-2 text-xs text-muted-foreground\">\n                Detected: {detected.map((d) => d.detectedLanguage).join(\", \")}\n              </div>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">\n                Model downloading… {downloadProgress}%\n              </div>\n            )}\n\n            {phase === \"generating\" && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Fixing grammar…\n                </div>\n                {resultText && (\n                  <Textarea\n                    value={resultText}\n                    readOnly\n                    className=\"min-h-[160px]\"\n                  />\n                )}\n              </div>\n            )}\n\n            {phase === \"result\" && (\n              <div className=\"space-y-3\">\n                <Textarea\n                  value={resultText}\n                  readOnly\n                  className=\"min-h-[200px]\"\n                />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === \"generating\" && (\n                <Button variant=\"outline\" onClick={handleStop}>\n                  Stop\n                </Button>\n              )}\n              {phase === \"result\" && (\n                <>\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => {\n                      setAiError(null);\n                      setPhase(\"generating\");\n                      (async () => {\n                        try {\n                          const text = inputRef.current?.value || \"\";\n                          const top =\n                            detected && detected.length > 0\n                              ? detected[0].detectedLanguage\n                              : \"en\";\n                          const res = await proofreadOnce(text, {\n                            expectedInputLanguages: [top],\n                            onProgress: (p) => setDownloadProgress(p),\n                          });\n                          setResultText(res.corrected);\n                          setPhase(\"result\");\n                        } catch (err) {\n                          const msg = (err as Error).message;\n                          setAiError(msg);\n                          setPhase(\"result\");\n                        }\n                      })();\n                    }}\n                  >\n                    Regenerate\n                  </Button>\n                  {typeof resultText === \"string\" &&\n                    resultText.trim().length > 0 && (\n                      <Button onClick={acceptResult}>Accept</Button>\n                    )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Improve Modal */}\n        <Dialog\n          open={isFeatureOpen && activeFeature === \"improve\"}\n          onOpenChange={(open: boolean) => {\n            if (!open) closeFeature();\n          }}\n        >\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Improve writing</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">\n                Model downloading… {downloadProgress}%\n              </div>\n            )}\n\n            {phase === \"prompt\" && (\n              <div className=\"space-y-3\">\n                <div className=\"grid grid-cols-3 gap-2\">\n                  <Select value={tone} onValueChange={(v) => setTone(v as any)}>\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Tone\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"as-is\">Tone: As-is</SelectItem>\n                      <SelectItem value=\"more-formal\">\n                        Tone: More formal\n                      </SelectItem>\n                      <SelectItem value=\"more-casual\">\n                        Tone: More casual\n                      </SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select\n                    value={lengthPref}\n                    onValueChange={(v) => setLengthPref(v as any)}\n                  >\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Length\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"as-is\">Length: As-is</SelectItem>\n                      <SelectItem value=\"shorter\">Length: Shorter</SelectItem>\n                      <SelectItem value=\"longer\">Length: Longer</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select\n                    value={formatPref}\n                    onValueChange={(v) => setFormatPref(v as any)}\n                  >\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Format\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"plain-text\">\n                        Format: Plain text\n                      </SelectItem>\n                      <SelectItem value=\"markdown\">Format: Markdown</SelectItem>\n                      <SelectItem value=\"as-is\">Format: As-is</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <Input\n                  placeholder=\"Optional context (e.g., audience or constraints)\"\n                  value={contextText}\n                  onChange={(e) => setContextText(e.target.value)}\n                />\n              </div>\n            )}\n\n            {phase === \"generating\" && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Improving…\n                </div>\n                {resultText && (\n                  <Textarea\n                    value={resultText}\n                    readOnly\n                    className=\"min-h-[160px]\"\n                  />\n                )}\n              </div>\n            )}\n\n            {phase === \"result\" && (\n              <div className=\"space-y-3\">\n                <Textarea\n                  value={resultText}\n                  readOnly\n                  className=\"min-h-[200px]\"\n                />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === \"prompt\" && (\n                <Button onClick={startImprove} disabled={isLoading}>\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Generate\n                </Button>\n              )}\n              {phase === \"generating\" && (\n                <Button variant=\"outline\" onClick={handleStop}>\n                  Stop\n                </Button>\n              )}\n              {phase === \"result\" && (\n                <>\n                  <Button variant=\"outline\" onClick={regen}>\n                    Regenerate\n                  </Button>\n                  {typeof resultText === \"string\" &&\n                    resultText.trim().length > 0 && (\n                      <Button onClick={acceptResult}>Accept</Button>\n                    )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Translate Modal */}\n        <Dialog\n          open={isFeatureOpen && activeFeature === \"translate\"}\n          onOpenChange={(open) => {\n            if (!open) closeFeature();\n          }}\n        >\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Translate</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {detected && detected.length > 0 && (\n              <div className=\"mb-2 text-xs text-muted-foreground\">\n                Detected source: {detected[0].detectedLanguage}\n              </div>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">\n                Model downloading… {downloadProgress}%\n              </div>\n            )}\n\n            {phase === \"prompt\" && (\n              <div className=\"space-y-3\">\n                <div className=\"grid grid-cols-1 gap-2\">\n                  <Select\n                    value={selectedTarget}\n                    onValueChange={(v) => setSelectedTarget(v)}\n                  >\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Select target language\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {translateTargets\n                        ?.filter((code: string) => {\n                          // Exclude detected source language from target options\n                          if (detected && detected.length > 0) {\n                            return code !== detected[0].detectedLanguage;\n                          }\n                          return true;\n                        })\n                        .map((code: string) => (\n                          <SelectItem key={code} value={code}>\n                            {translateLanguageMap?.[code] || code}\n                          </SelectItem>\n                        ))}\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n            )}\n\n            {phase === \"generating\" && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Translating…\n                </div>\n                {resultText && (\n                  <Textarea\n                    value={resultText}\n                    readOnly\n                    className=\"min-h-[160px]\"\n                  />\n                )}\n              </div>\n            )}\n\n            {phase === \"result\" && (\n              <div className=\"space-y-3\">\n                <Textarea\n                  value={resultText}\n                  readOnly\n                  className=\"min-h-[200px]\"\n                />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === \"prompt\" && (\n                <Button\n                  onClick={startTranslate}\n                  disabled={!selectedTarget || isLoading}\n                >\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Translate\n                </Button>\n              )}\n              {phase === \"generating\" && (\n                <Button variant=\"outline\" onClick={handleStop}>\n                  Stop\n                </Button>\n              )}\n              {phase === \"result\" && (\n                <>\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => {\n                      setPhase(\"prompt\");\n                      setResultText(\"\");\n                      setAiError(null);\n                    }}\n                  >\n                    Regenerate\n                  </Button>\n                  {typeof resultText === \"string\" &&\n                    resultText.trim().length > 0 && (\n                      <Button onClick={acceptResult}>Accept</Button>\n                    )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      </div>\n    );\n  }\n);\n\nGenUIInput.displayName = \"GenUIInput\";\n\n// Local state for Improve controls\nfunction useImproveControls() {\n  const [tone, setTone] = React.useState<\n    \"more-formal\" | \"as-is\" | \"more-casual\"\n  >(\"as-is\");\n  const [lengthPref, setLengthPref] = React.useState<\n    \"shorter\" | \"as-is\" | \"longer\"\n  >(\"as-is\");\n  const [formatPref, setFormatPref] = React.useState<\n    \"as-is\" | \"markdown\" | \"plain-text\"\n  >(\"plain-text\");\n  const [contextText, setContextText] = React.useState(\"\");\n  return {\n    tone,\n    setTone,\n    lengthPref,\n    setLengthPref,\n    formatPref,\n    setFormatPref,\n    contextText,\n    setContextText,\n  };\n}\n\nfunction startImproveFactory(\n  rewriterRef: React.MutableRefObject<any>,\n  ensureRewriter: () => Promise<any | null>,\n  setIsLoading: (b: boolean) => void,\n  setAiError: (s: string | null) => void,\n  setResultText: (s: string) => void,\n  setPhase: (p: \"prompt\" | \"generating\" | \"result\") => void,\n  inputRef: React.RefObject<HTMLInputElement>,\n  contextText: string,\n  onAIError?: (e: Error) => void\n) {\n  return async function startImprove() {\n    setAiError(null);\n    setResultText(\"\");\n    setPhase(\"generating\");\n    setIsLoading(true);\n    try {\n      const text = inputRef.current?.value || \"\";\n      if (!text.trim()) throw new Error(\"Please enter some text to improve.\");\n      const rewriter = rewriterRef.current ?? (await ensureRewriter());\n      if (!rewriter) {\n        setIsLoading(false);\n        setPhase(\"prompt\");\n        return;\n      }\n      let result = \"\";\n      if (typeof rewriter.rewrite === \"function\") {\n        result = await rewriter.rewrite(text, {\n          context: contextText || undefined,\n        });\n      } else if (typeof rewriter.rewriteStreaming === \"function\") {\n        let acc = \"\";\n        for await (const chunk of rewriter.rewriteStreaming(text, {\n          context: contextText || undefined,\n        })) {\n          acc += chunk;\n        }\n        result = acc;\n      }\n      setResultText(result);\n      setPhase(\"result\");\n    } catch (err) {\n      const msg = (err as Error).message;\n      setAiError(msg);\n      onAIError?.(err as Error);\n      setPhase(\"prompt\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n}\n",
      "type": "registry:component"
    }
  ]
}