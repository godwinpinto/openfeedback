{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-provider",
  "type": "registry:block",
  "title": "GUI Provider",
  "description": "Provider component for Chrome AI APIs (Summarizer, Writer, Rewriter, Language Detector).",
  "dependencies": [],
  "registryDependencies": [
    "button",
    "alert",
    "dialog",
    "tooltip",
    "skeleton"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/shared/genui-provider.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { SummarizeSelection } from \"./genui-summarize-selection\";\nimport {\n  SummarizeOptions,\n  SummarizerOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\nimport {\n  WriterOptions,\n  RewriterOptions,\n  WriteOptions,\n  RewriteOptions,\n  LanguageDetectorOptions,\n  DetectedLanguage,\n  AvailabilityStatus,\n  LanguageModelAvailabilityStatus,\n  PromptOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\n\n\nexport interface GenUIContextValue extends LanguageModelAvailabilityStatus {\n  // State\n  isSupported: boolean | null;\n  isWriterSupported: boolean | null;\n  isRewriterSupported: boolean | null;\n  isLanguageDetectorSupported: boolean | null;\n  availability: AvailabilityStatus;\n  writerAvailability: AvailabilityStatus;\n  rewriterAvailability: AvailabilityStatus;\n  languageDetectorAvailability: AvailabilityStatus;\n  downloadProgress: number;\n  writerDownloadProgress: number;\n  rewriterDownloadProgress: number;\n  languageDetectorDownloadProgress: number;\n  isDownloading: boolean;\n  isWriterDownloading: boolean;\n  isRewriterDownloading: boolean;\n  isLanguageDetectorDownloading: boolean;\n  error: string | null;\n\n  // Functions\n  checkAvailability: () => Promise<AvailabilityStatus>;\n  checkWriterAvailability: () => Promise<AvailabilityStatus>;\n  checkRewriterAvailability: () => Promise<AvailabilityStatus>;\n  checkLanguageDetectorAvailability: () => Promise<AvailabilityStatus>;\n  createSummarizer: (options?: SummarizerOptions) => Promise<any>;\n  createWriter: (options?: WriterOptions) => Promise<any>;\n  createRewriter: (options?: RewriterOptions) => Promise<any>;\n  createLanguageDetector: (options?: LanguageDetectorOptions) => Promise<any>;\n  summarize: (\n    text: string,\n    options?: SummarizeOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  write: (\n    prompt: string,\n    options?: WriteOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  rewrite: (\n    text: string,\n    options?: RewriteOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  detectLanguage: (text: string) => Promise<DetectedLanguage[]>;\n  resetError: () => void;\n}\n\nconst GenUIContext = React.createContext<GenUIContextValue | undefined>(\n  undefined\n);\n\nexport interface GenUIProviderProps {\n  children: React.ReactNode;\n  defaultOptions?: SummarizerOptions;\n  defaultWriterOptions?: WriterOptions;\n  defaultRewriterOptions?: RewriterOptions;\n  defaultLanguageDetectorOptions?: LanguageDetectorOptions;\n  enableSelectionSummarizer?: boolean;\n}\n\nexport function GenUIProvider({\n  children,\n  defaultOptions,\n  defaultWriterOptions,\n  defaultLanguageDetectorOptions,\n  defaultRewriterOptions,\n  enableSelectionSummarizer = false,\n}: GenUIProviderProps) {\n  const [isSupported, setIsSupported] = React.useState<boolean | null>(null);\n  const [isWriterSupported, setIsWriterSupported] = React.useState<\n    boolean | null\n  >(null);\n  const [isRewriterSupported, setIsRewriterSupported] = React.useState<\n    boolean | null\n  >(null);\n  const [isLanguageDetectorSupported, setIsLanguageDetectorSupported] =\n    React.useState<boolean | null>(null);\n  const [availability, setAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [writerAvailability, setWriterAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [rewriterAvailability, setRewriterAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [languageDetectorAvailability, setLanguageDetectorAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [downloadProgress, setDownloadProgress] = React.useState(0);\n  const [writerDownloadProgress, setWriterDownloadProgress] = React.useState(0);\n  const [rewriterDownloadProgress, setRewriterDownloadProgress] =\n    React.useState(0);\n  const [\n    languageDetectorDownloadProgress,\n    setLanguageDetectorDownloadProgress,\n  ] = React.useState(0);\n  const [isDownloading, setIsDownloading] = React.useState(false);\n  const [isWriterDownloading, setIsWriterDownloading] = React.useState(false);\n  const [isRewriterDownloading, setIsRewriterDownloading] =\n    React.useState(false);\n  const [isLanguageDetectorDownloading, setIsLanguageDetectorDownloading] =\n    React.useState(false);\n  const [error, setError] = React.useState<string | null>(null);\n  const hasCheckedAvailability = React.useRef(false);\n  const hasCheckedWriterAvailability = React.useRef(false);\n  const hasCheckedRewriterAvailability = React.useRef(false);\n  const hasCheckedLanguageDetectorAvailability = React.useRef(false);\n\n  // LanguageModel Prompt API state\n  const [isLanguageModelSupported, setIsLanguageModelSupported] =\n    React.useState<boolean | null>(null);\n  const [languageModelAvailability, setLanguageModelAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [languageModelError, setLanguageModelError] = React.useState<\n    string | null\n  >(null);\n  const hasCheckedLanguageModelAvailability = React.useRef(false);\n\n  // Check if Chrome Summarizer API is supported\n  React.useEffect(() => {\n    const checkSupport = () => {\n      const hasSummarizer = \"Summarizer\" in self;\n      const hasWriter = \"Writer\" in self;\n      const hasLanguageDetector = \"LanguageDetector\" in self;\n      const hasRewriter = \"Rewriter\" in self;\n\n      setIsSupported(hasSummarizer);\n      setIsWriterSupported(hasWriter);\n      setIsRewriterSupported(hasRewriter);\n      setIsLanguageDetectorSupported(hasLanguageDetector);\n\n      if (\n        !hasSummarizer &&\n        !hasWriter &&\n        !hasRewriter &&\n        !hasLanguageDetector\n      ) {\n        const errorMsg =\n          \"Chrome AI APIs are not supported in this browser. Please use Chrome 137+ with the required hardware specifications.\";\n        setError(errorMsg);\n      }\n    };\n\n    checkSupport();\n  }, []);\n\n  // Check if Chrome LanguageModel Prompt API is supported\n  React.useEffect(() => {\n    const checkLanguageModelSupport = () => {\n      if (\"LanguageModel\" in self) {\n        setIsLanguageModelSupported(true);\n      } else {\n        setIsLanguageModelSupported(false);\n        const errorMsg =\n          \"Chrome Prompt API (LanguageModel) is not supported in this browser. Please use Chrome 138+ with the required hardware specifications.\";\n        setLanguageModelError(errorMsg);\n      }\n    };\n\n    checkLanguageModelSupport();\n  }, []);\n\n  // Check model availability\n  const checkAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (\n          self as any\n        ).Summarizer.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Summarizer API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsDownloading(true);\n          setDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check summarizer availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setAvailability(null);\n        return null;\n      }\n    }, [isSupported]);\n\n  // Check Writer model availability\n  const checkWriterAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (self as any).Writer.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Writer API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setWriterAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setWriterAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsWriterDownloading(true);\n          setWriterDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check writer availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setWriterAvailability(null);\n        return null;\n      }\n    }, [isWriterSupported]);\n\n  // Automatically check availability when support is confirmed\n  React.useEffect(() => {\n    if (isSupported === true && !hasCheckedAvailability.current) {\n      hasCheckedAvailability.current = true;\n      checkAvailability();\n    }\n  }, [isSupported, checkAvailability]);\n\n  // Check Language Detector model availability\n  const checkLanguageDetectorAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (\n          self as any\n        ).LanguageDetector.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Language Detector API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setLanguageDetectorAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setLanguageDetectorAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsLanguageDetectorDownloading(true);\n          setLanguageDetectorDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check language detector availability: \" +\n          (err as Error).message;\n        setError(errorMsg);\n        setLanguageDetectorAvailability(null);\n        return null;\n      }\n    }, [isLanguageDetectorSupported]);\n\n  // Automatically check writer availability when support is confirmed\n  React.useEffect(() => {\n    if (isWriterSupported === true && !hasCheckedWriterAvailability.current) {\n      hasCheckedWriterAvailability.current = true;\n      checkWriterAvailability();\n    }\n  }, [isWriterSupported, checkWriterAvailability]);\n\n  // Check Rewriter model availability\n  const checkRewriterAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (self as any).Rewriter.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Rewriter API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setRewriterAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setRewriterAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsRewriterDownloading(true);\n          setRewriterDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check rewriter availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setRewriterAvailability(null);\n        return null;\n      }\n    }, [isRewriterSupported]);\n\n  // Automatically check rewriter availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isRewriterSupported === true &&\n      !hasCheckedRewriterAvailability.current\n    ) {\n      hasCheckedRewriterAvailability.current = true;\n      checkRewriterAvailability();\n    }\n  }, [isRewriterSupported, checkRewriterAvailability]);\n\n  // Automatically check language detector availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isLanguageDetectorSupported === true &&\n      !hasCheckedLanguageDetectorAvailability.current\n    ) {\n      hasCheckedLanguageDetectorAvailability.current = true;\n      checkLanguageDetectorAvailability();\n    }\n  }, [isLanguageDetectorSupported, checkLanguageDetectorAvailability]);\n\n  // Create summarizer instance\n  const createSummarizer = React.useCallback(\n    async (options?: SummarizerOptions): Promise<any> => {\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const summarizerOptions: SummarizerOptions = {\n          ...defaultOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setDownloadProgress(progress);\n            });\n          },\n        };\n\n        const summarizer = await (self as any).Summarizer.create(\n          summarizerOptions\n        );\n        setIsDownloading(false);\n        setDownloadProgress(100);\n        setError(null);\n        return summarizer;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to create summarizer: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsDownloading(false);\n        return null;\n      }\n    },\n    [isSupported, defaultOptions]\n  );\n\n  // Summarize function (batch or streaming)\n  const summarize = React.useCallback(\n    async (\n      text: string,\n      options?: SummarizeOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to summarize.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Summarizer is not available.\");\n        }\n\n        // Create summarizer\n        const summarizer = await createSummarizer();\n        if (!summarizer) {\n          throw new Error(\"Failed to create summarizer.\");\n        }\n\n        const summarizeOptions: SummarizeOptions = {\n          context:\n            options?.context ||\n            defaultOptions?.sharedContext ||\n            \"This text is being summarized for better understanding.\",\n        };\n\n        // Perform summarization\n        if (options?.streaming) {\n          const stream = summarizer.summarizeStreaming(text, summarizeOptions);\n          let result = \"\";\n\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n\n          return result;\n        } else {\n          const result = await summarizer.summarize(text, summarizeOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [isSupported, checkAvailability, createSummarizer, defaultOptions]\n  );\n\n  // Create writer instance\n  const createWriter = React.useCallback(\n    async (options?: WriterOptions): Promise<any> => {\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const writerOptions: WriterOptions = {\n          ...defaultWriterOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setWriterDownloadProgress(progress);\n            });\n          },\n        };\n\n        const writer = await (self as any).Writer.create(writerOptions);\n        setIsWriterDownloading(false);\n        setWriterDownloadProgress(100);\n        setError(null);\n        return writer;\n      } catch (err) {\n        const errorMsg = \"Failed to create writer: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsWriterDownloading(false);\n        return null;\n      }\n    },\n    [isWriterSupported, defaultWriterOptions]\n  );\n\n  // Write function (batch or streaming)\n  const write = React.useCallback(\n    async (\n      prompt: string,\n      options?: WriteOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!prompt.trim()) {\n        const errorMsg = \"Please enter a prompt to write content.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkWriterAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Writer is not available.\");\n        }\n\n        // Create writer\n        const writer = await createWriter();\n        if (!writer) {\n          throw new Error(\"Failed to create writer.\");\n        }\n\n        const writeOptions: WriteOptions = {\n          context:\n            options?.context ||\n            defaultWriterOptions?.sharedContext ||\n            \"Generate helpful and appropriate content.\",\n        };\n\n        // Perform writing\n        if (options?.streaming) {\n          const stream = writer.writeStreaming(prompt, writeOptions);\n          let result = \"\";\n\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n\n          return result;\n        } else {\n          const result = await writer.write(prompt, writeOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isWriterSupported,\n      checkWriterAvailability,\n      createWriter,\n      defaultWriterOptions,\n    ]\n  );\n\n  // Create rewriter instance\n  const createRewriter = React.useCallback(\n    async (options?: RewriterOptions): Promise<any> => {\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const rewriterOptions: RewriterOptions = {\n          ...defaultRewriterOptions,\n          ...options,\n          monitor: (monitor) => {\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setRewriterDownloadProgress(progress);\n            });\n          },\n        };\n\n        const rewriter = await (self as any).Rewriter.create(rewriterOptions);\n        setIsRewriterDownloading(false);\n        setRewriterDownloadProgress(100);\n        setError(null);\n        return rewriter;\n      } catch (err) {\n        const errorMsg = \"Failed to create rewriter: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsRewriterDownloading(false);\n        return null;\n      }\n    },\n    [isRewriterSupported, defaultRewriterOptions]\n  );\n\n  // Rewrite function (batch or streaming)\n  const rewrite = React.useCallback(\n    async (\n      text: string,\n      options?: RewriteOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to improve.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        const availabilityStatus = await checkRewriterAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Rewriter is not available.\");\n        }\n\n        const rewriter = await createRewriter();\n        if (!rewriter) {\n          throw new Error(\"Failed to create rewriter.\");\n        }\n\n        const rewriteOptions: RewriteOptions = {\n          context:\n            options?.context ||\n            defaultRewriterOptions?.sharedContext ||\n            \"Improve clarity and readability without changing meaning.\",\n          signal: options?.signal,\n        };\n\n        if (options?.streaming) {\n          const stream = rewriter.rewriteStreaming(text, rewriteOptions);\n          let result = \"\";\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n          return result;\n        } else {\n          const result = await rewriter.rewrite(text, rewriteOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isRewriterSupported,\n      checkRewriterAvailability,\n      createRewriter,\n      defaultRewriterOptions,\n    ]\n  );\n\n  // Create language detector instance\n  const createLanguageDetector = React.useCallback(\n    async (options?: LanguageDetectorOptions): Promise<any> => {\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const detectorOptions: LanguageDetectorOptions = {\n          ...defaultLanguageDetectorOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setLanguageDetectorDownloadProgress(progress);\n            });\n          },\n        };\n\n        const detector = await (self as any).LanguageDetector.create(\n          detectorOptions\n        );\n        setIsLanguageDetectorDownloading(false);\n        setLanguageDetectorDownloadProgress(100);\n        setError(null);\n        return detector;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to create language detector: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsLanguageDetectorDownloading(false);\n        return null;\n      }\n    },\n    [isLanguageDetectorSupported, defaultLanguageDetectorOptions]\n  );\n\n  // Detect language function\n  const detectLanguage = React.useCallback(\n    async (text: string): Promise<DetectedLanguage[]> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to detect language.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkLanguageDetectorAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Language Detector is not available.\");\n        }\n\n        // Create language detector\n        const detector = await createLanguageDetector();\n        if (!detector) {\n          throw new Error(\"Failed to create language detector.\");\n        }\n\n        // Perform language detection\n        const results = await detector.detect(text);\n        return results;\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isLanguageDetectorSupported,\n      checkLanguageDetectorAvailability,\n      createLanguageDetector,\n    ]\n  );\n\n  // Check LanguageModel availability\n  const checkLanguageModelAvailability = React.useCallback(\n    async (options?: PromptOptions): Promise<AvailabilityStatus> => {\n      if (!isLanguageModelSupported) {\n        const errorMsg = \"Chrome Prompt API (LanguageModel) is not supported.\";\n        setLanguageModelError(errorMsg);\n        return null;\n      }\n      try {\n        // Always pass the same options to availability() that will be used in prompt()\n        const availabilityStatus = await (\n          self as any\n        ).LanguageModel.availability(options);\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Prompt API (LanguageModel) is not available on this device. Please check hardware requirements.\";\n          setLanguageModelError(errorMsg);\n          setLanguageModelAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setLanguageModelAvailability(availabilityStatus);\n        setLanguageModelError(null);\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check LanguageModel availability: \" +\n          (err as Error).message;\n        setLanguageModelError(errorMsg);\n        setLanguageModelAvailability(null);\n        return null;\n      }\n    },\n    [isLanguageModelSupported]\n  );\n\n  // Automatically check LanguageModel availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isLanguageModelSupported === true &&\n      !hasCheckedLanguageModelAvailability.current\n    ) {\n      hasCheckedLanguageModelAvailability.current = true;\n      checkLanguageModelAvailability();\n    }\n  }, [isLanguageModelSupported, checkLanguageModelAvailability]);\n\n  // Reset error\n  const resetError = React.useCallback(() => {\n    setError(null);\n  }, []);\n\n  const value: GenUIContextValue = React.useMemo(\n    () => ({\n      // Summarizer API\n      isSupported,\n      isWriterSupported,\n      isRewriterSupported,\n      isLanguageDetectorSupported,\n      availability,\n      writerAvailability,\n      rewriterAvailability,\n      languageDetectorAvailability,\n      downloadProgress,\n      writerDownloadProgress,\n      rewriterDownloadProgress,\n      languageDetectorDownloadProgress,\n      isDownloading,\n      isWriterDownloading,\n      isRewriterDownloading,\n      isLanguageDetectorDownloading,\n      error,\n      checkAvailability,\n      checkWriterAvailability,\n      checkRewriterAvailability,\n      checkLanguageDetectorAvailability,\n      createSummarizer,\n      createWriter,\n      createRewriter,\n      createLanguageDetector,\n      summarize,\n      write,\n      rewrite,\n      detectLanguage,\n      resetError,\n      // LanguageModel Prompt API\n      isLanguageModelSupported,\n      languageModelAvailability,\n      languageModelError,\n      checkLanguageModelAvailability,\n    }),\n    [\n      isSupported,\n      isWriterSupported,\n      isRewriterSupported,\n      isLanguageDetectorSupported,\n      availability,\n      writerAvailability,\n      rewriterAvailability,\n      languageDetectorAvailability,\n      downloadProgress,\n      writerDownloadProgress,\n      rewriterDownloadProgress,\n      languageDetectorDownloadProgress,\n      isDownloading,\n      isWriterDownloading,\n      isRewriterDownloading,\n      isLanguageDetectorDownloading,\n      error,\n      checkAvailability,\n      checkWriterAvailability,\n      checkRewriterAvailability,\n      checkLanguageDetectorAvailability,\n      createSummarizer,\n      createWriter,\n      createRewriter,\n      createLanguageDetector,\n      summarize,\n      write,\n      rewrite,\n      detectLanguage,\n      resetError,\n      isLanguageModelSupported,\n      languageModelAvailability,\n      languageModelError,\n      checkLanguageModelAvailability,\n    ]\n  );\n\n  return (\n    <GenUIContext.Provider value={value}>\n      {children}\n      {enableSelectionSummarizer ? (\n        // Lazy import to avoid SSR issues if any consumer renders on server\n        <SummarizeSelection defaultOptions={defaultOptions} />\n      ) : null}\n    </GenUIContext.Provider>\n  );\n}\n\n// Hook to use Voiceable context\nexport function useGenUI(): GenUIContextValue {\n  const context = React.useContext(GenUIContext);\n  if (context === undefined) {\n    throw new Error(\"useGenUI must be used within a GenUIProvider\");\n  }\n  return context;\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/genui-types.ts",
      "content": "// Type definitions for Chrome Summarizer API\nexport interface SummarizerOptions {\n  sharedContext?: string;\n  type?: \"key-points\" | \"tldr\" | \"teaser\" | \"headline\";\n  format?: \"markdown\" | \"plain-text\";\n  length?: \"short\" | \"medium\" | \"long\";\n  expectedInputLanguages?: string[];\n  outputLanguage?: string;\n  expectedContextLanguages?: string[];\n  monitor?: (monitor: any) => void;\n}\n\nexport interface SummarizeOptions {\n  context?: string;\n}\n\nexport interface SummarizeSelectionProps {\n  className?: string;\n  defaultOptions?: SummarizerOptions;\n  dialogTitle?: string;\n}\n\nexport interface ButtonPosition {\n  top: number;\n  left: number;\n  visible: boolean;\n}\n\nexport interface UseSummarizerOptions extends SummarizerOptions {\n  context?: string;\n}\n\n// Type definitions for Chrome Writer API\nexport interface WriterOptions {\n  sharedContext?: string;\n  tone?: \"formal\" | \"neutral\" | \"casual\";\n  format?: \"markdown\" | \"plain-text\";\n  length?: \"short\" | \"medium\" | \"long\";\n  expectedInputLanguages?: string[];\n  expectedContextLanguages?: string[];\n  outputLanguage?: string;\n  monitor?: (monitor: any) => void;\n  signal?: AbortSignal;\n}\n\nexport interface WriteOptions {\n  context?: string;\n}\n\n// Type definitions for Chrome Rewriter API\nexport interface RewriterOptions {\n  sharedContext?: string;\n  tone?: \"more-formal\" | \"as-is\" | \"more-casual\";\n  format?: \"as-is\" | \"markdown\" | \"plain-text\";\n  length?: \"shorter\" | \"as-is\" | \"longer\";\n  expectedInputLanguages?: string[];\n  expectedContextLanguages?: string[];\n  outputLanguage?: string;\n  monitor?: (monitor: any) => void;\n  signal?: AbortSignal;\n}\n\nexport interface RewriteOptions {\n  context?: string;\n  signal?: AbortSignal;\n}\n\nexport interface DetectedLanguage {\n  detectedLanguage: string;\n  confidence: number;\n}\n\n\n// Type definitions for Chrome Language Detector API\nexport interface LanguageDetectorOptions {\n  monitor?: (monitor: any) => void;\n}\n\nexport interface DetectedLanguage {\n  detectedLanguage: string;\n  confidence: number;\n}\n\nexport type AvailabilityStatus =\n  | \"available\"\n  | \"downloadable\"\n  | \"unavailable\"\n  | null;\n\n// LanguageModel Prompt API types\nexport interface PromptOptions {\n  temperature?: number;\n  topK?: number;\n  responseConstraint?: any; // JSON Schema for structured output\n  omitResponseConstraintInput?: boolean;\n  signal?: AbortSignal;\n}\n\nexport interface LanguageModelAvailabilityStatus {\n  // State\n  isLanguageModelSupported: boolean | null;\n  languageModelAvailability: AvailabilityStatus;\n  languageModelError: string | null;\n\n  // Functions\n  checkLanguageModelAvailability: (\n    options?: PromptOptions\n  ) => Promise<AvailabilityStatus>;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/use-genui-summarizer.ts",
      "content": "'use client';\n\nimport * as React from 'react';\nimport type { UseSummarizerOptions, SummarizeOptions,SummarizerOptions } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\nimport { ensureSummarizer } from '@/registry/new-york/gencn-ui/items/shared/lib/summarizer';\n\n\n\n\nexport interface UseSummarizerReturn {\n  isLoading: boolean;\n  error: Error | null;\n  progress: number | null;\n  result: string;\n  run: (text: string, options?: SummarizeOptions) => Promise<string>;\n  runStreaming: (text: string, options?: SummarizeOptions) => Promise<string>;\n  stop: () => void;\n  reset: () => void;\n}\n\nexport function useSummarizer(options?: UseSummarizerOptions): UseSummarizerReturn {\n  const [isLoading, setIsLoading] = React.useState(false);\n  const [error, setError] = React.useState<Error | null>(null);\n  const [progress, setProgress] = React.useState<number | null>(null);\n  const [result, setResult] = React.useState('');\n  const abortRef = React.useRef<AbortController | null>(null);\n  const summarizerRef = React.useRef<any>(null);\n\n  const stop = React.useCallback(() => {\n    abortRef.current?.abort();\n    abortRef.current = null;\n  }, []);\n\n  const reset = React.useCallback(() => {\n    setIsLoading(false);\n    setError(null);\n    setProgress(null);\n    setResult('');\n  }, []);\n\n  const getSummarizer = React.useCallback(async () => {\n    if (summarizerRef.current) return summarizerRef.current;\n    summarizerRef.current = await ensureSummarizer({\n      ...options,\n      onProgress: (p) => setProgress(p),\n    });\n    return summarizerRef.current;\n  }, [options]);\n\n  const run = React.useCallback(async (text: string, summarizeOptions?: SummarizeOptions) => {\n    setIsLoading(true);\n    setError(null);\n    setResult('');\n    try {\n      const summarizer = await getSummarizer();\n      const res = await summarizer.summarize(text, {\n        context: summarizeOptions?.context ?? options?.sharedContext ?? options?.context,\n      });\n      setResult(res);\n      return res as string;\n    } catch (e) {\n      setError(e as Error);\n      throw e;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSummarizer, options]);\n\n  const runStreaming = React.useCallback(async (text: string, summarizeOptions?: SummarizeOptions) => {\n    setIsLoading(true);\n    setError(null);\n    setResult('');\n    abortRef.current?.abort();\n    abortRef.current = new AbortController();\n    try {\n      const summarizer = await getSummarizer();\n      const stream = summarizer.summarizeStreaming(text, {\n        context: summarizeOptions?.context ?? options?.sharedContext ?? options?.context,\n        signal: abortRef.current.signal,\n      });\n      let acc = '';\n      for await (const chunk of stream) {\n        acc += chunk;\n        setResult(acc);\n      }\n      return acc;\n    } catch (e) {\n      if ((e as any)?.name === 'AbortError') return result;\n      setError(e as Error);\n      throw e;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSummarizer, options, result]);\n\n  React.useEffect(() => () => stop(), [stop]);\n\n  return { isLoading, error, progress, result, run, runStreaming, stop, reset };\n}\n\n\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/genui-summarize-selection.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Button } from '@/components/ui/button';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { cn } from '@/lib/utils';\nimport { Sparkles, Repeat2 } from 'lucide-react';\nimport { type UseSummarizerOptions, ButtonPosition, SummarizeSelectionProps } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\nimport { useSummarizer } from '@/registry/new-york/gencn-ui/items/shared/use-genui-summarizer';\n\n\n\nexport function SummarizeSelection({ className, defaultOptions, dialogTitle = 'Summary' }: SummarizeSelectionProps) {\n  const [selectionText, setSelectionText] = React.useState<string>('');\n  const [position, setPosition] = React.useState<ButtonPosition>({ top: 0, left: 0, visible: false });\n  const [open, setOpen] = React.useState(false);\n  const debounceRef = React.useRef<number | null>(null);\n  const rangeRef = React.useRef<Range | null>(null);\n  const isSelectionReversedRef = React.useRef<boolean>(false);\n\n  const { isLoading, error, result, runStreaming, run, reset } = useSummarizer({\n    ...defaultOptions,\n  } as UseSummarizerOptions);\n\n  const clearPosition = React.useCallback(() => {\n    setPosition((p) => ({ ...p, visible: false }));\n  }, []);\n\n  const getTargetRect = React.useCallback((range: Range): DOMRect | null => {\n    const rects = range.getClientRects();\n    if (!rects || rects.length === 0) return range.getBoundingClientRect();\n    // For reversed selections (bottom to top), use the first rect\n    // For normal selections (top to bottom), use the last rect\n    if (isSelectionReversedRef.current) {\n      for (let i = 0; i < rects.length; i++) {\n        const r = rects[i];\n        if (r && r.width > 0 && r.height > 0) return r as DOMRect;\n      }\n    } else {\n      // Prefer the last non-empty rect for multi-line selections\n      for (let i = rects.length - 1; i >= 0; i--) {\n        const r = rects[i];\n        if (r && r.width > 0 && r.height > 0) return r as DOMRect;\n      }\n    }\n    return range.getBoundingClientRect();\n  }, []);\n\n  const updateFromSelection = React.useCallback(() => {\n    if (open) {\n      clearPosition();\n      return;\n    }\n    const sel = window.getSelection?.();\n    if (!sel || sel.isCollapsed || !sel.rangeCount) {\n      setSelectionText('');\n      clearPosition();\n      rangeRef.current = null;\n      return;\n    }\n    const range = sel.getRangeAt(0);\n    const text = sel.toString().trim();\n    if (!text) {\n      setSelectionText('');\n      clearPosition();\n      rangeRef.current = null;\n      return;\n    }\n\n    // Detect selection direction: if anchor comes after focus, selection was made bottom to top\n    const anchorNode = sel.anchorNode;\n    const focusNode = sel.focusNode;\n    let isReversed = false;\n    \n    if (anchorNode && focusNode) {\n      if (anchorNode === focusNode) {\n        // Same node, compare offsets\n        isReversed = sel.anchorOffset > sel.focusOffset;\n      } else {\n        // Different nodes: create ranges at anchor and focus points and compare them\n        const anchorRange = document.createRange();\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        \n        const focusRange = document.createRange();\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n        \n        // Compare which range comes first in document order\n        // If anchor range comes after focus range, selection was reversed (bottom to top)\n        const comparison = anchorRange.compareBoundaryPoints(Range.START_TO_START, focusRange);\n        isReversed = comparison > 0;\n      }\n    }\n    \n    isSelectionReversedRef.current = isReversed;\n\n    rangeRef.current = range.cloneRange();\n    const rect = getTargetRect(rangeRef.current);\n    \n    // If selection is reversed (bottom to top), show button above the selection\n    // If selection is normal (top to bottom), show button below the selection\n    const BUTTON_HEIGHT = 32; // Approximate button height (h-8 = 32px)\n    const SPACING = 6;\n    const top = isReversed \n      ? (rect?.top ?? 0) - BUTTON_HEIGHT - SPACING\n      : (rect?.bottom ?? 0) + SPACING;\n    const left = (rect?.right ?? 0) + 6;\n    setSelectionText(text);\n    setPosition({ top, left, visible: true });\n  }, [clearPosition, getTargetRect, open]);\n\n  const debouncedUpdate = React.useCallback(() => {\n    if (debounceRef.current) window.clearTimeout(debounceRef.current);\n    debounceRef.current = window.setTimeout(updateFromSelection, 100);\n  }, [updateFromSelection]);\n\n  React.useEffect(() => {\n    const onSelectionChange = () => debouncedUpdate();\n    document.addEventListener('selectionchange', onSelectionChange);\n    const onScrollOrResize = () => {\n      if (open) return;\n      if (rangeRef.current) {\n        const rect = getTargetRect(rangeRef.current);\n        const BUTTON_HEIGHT = 32; // Approximate button height (h-8 = 32px)\n        const SPACING = 6;\n        const isReversed = isSelectionReversedRef.current;\n        const top = isReversed \n          ? (rect?.top ?? 0) - BUTTON_HEIGHT - SPACING\n          : (rect?.bottom ?? 0) + SPACING;\n        const left = (rect?.right ?? 0) + 6;\n        setPosition((p) => ({ ...p, top, left }));\n      }\n    };\n    window.addEventListener('scroll', onScrollOrResize, true);\n    window.addEventListener('resize', onScrollOrResize, true);\n    return () => {\n      document.removeEventListener('selectionchange', onSelectionChange);\n      window.removeEventListener('scroll', onScrollOrResize, true);\n      window.removeEventListener('resize', onScrollOrResize, true);\n      if (debounceRef.current) window.clearTimeout(debounceRef.current);\n    };\n  }, [debouncedUpdate, getTargetRect]);\n\n  const handleOpen = React.useCallback(async () => {\n    if (!selectionText) return;\n    setOpen(true);\n    reset();\n    try {\n      // Prefer streaming\n      await runStreaming(selectionText, {});\n    } catch {\n      // Fallback to non-streaming\n      try {\n        await run(selectionText, {});\n      } catch {}\n    }\n  }, [selectionText, runStreaming, run, reset]);\n\n  // Hide the button when dialog opens to avoid overlap\n  React.useEffect(() => {\n    if (open) clearPosition();\n  }, [open, clearPosition]);\n\n  return (\n    <>\n      {!open && position.visible && (\n        <div\n          className={cn('fixed z-50', className)}\n          style={{ top: position.top, left: position.left }}\n        >\n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                type=\"button\"\n                size=\"icon\"\n                variant=\"outline\"\n                className=\"h-8 w-8 rounded-lg shadow\"\n                onMouseDown={(e: React.MouseEvent<HTMLButtonElement>) => e.preventDefault()}\n                onClick={() => void handleOpen()}\n              >\n                <Sparkles className=\"h-4 w-4\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>Summarize selection</TooltipContent>\n          </Tooltip>\n        </div>\n      )}\n\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogContent className=\"sm:max-w-xl\">\n          <DialogHeader>\n            <DialogTitle>{dialogTitle}</DialogTitle>\n          </DialogHeader>\n          {error && (\n            <Alert variant=\"destructive\">\n              <AlertTitle>Error</AlertTitle>\n              <AlertDescription>{error.message}</AlertDescription>\n            </Alert>\n          )}\n          <div className=\"space-y-3\">\n            {isLoading ? (\n              <div className=\"space-y-3\">\n                <Skeleton className=\"h-4 w-3/4\" />\n                <Skeleton className=\"h-4 w-5/6\" />\n                <Skeleton className=\"h-4 w-2/3\" />\n                <Skeleton className=\"h-4 w-4/5\" />\n              </div>\n            ) : (\n              <div className=\"whitespace-pre-wrap\">\n                {result || 'No summary yet.'}\n              </div>\n            )}\n          </div>\n          <div className=\"mt-4 flex justify-end\">\n            <Tooltip>\n              <TooltipTrigger asChild>\n                <Button\n                  type=\"button\"\n                  size=\"sm\"\n                  variant=\"outline\"\n                  onClick={() => void handleOpen()}\n                  disabled={isLoading || !selectionText}\n                >\n                  <Repeat2 className=\"h-4 w-4\" />\n                  Re-Summarize\n                </Button>\n              </TooltipTrigger>\n              <TooltipContent>Resummarize</TooltipContent>\n            </Tooltip>\n          </div>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/language-detector.ts",
      "content": "'use client';\n\nimport type { LanguageDetectorOptions, DetectedLanguage } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\n\nexport type LanguageDetectorAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport function isLanguageDetectorSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'LanguageDetector' in self;\n}\n\nexport async function checkLanguageDetectorAvailability(): Promise<LanguageDetectorAvailability> {\n\tif (!isLanguageDetectorSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).LanguageDetector.availability();\n\t\treturn status as LanguageDetectorAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureLanguageDetector(options?: LanguageDetectorOptions & { onProgress?: (percent: number) => void }): Promise<any> {\n\tif (!isLanguageDetectorSupported()) {\n\t\tthrow new Error('Chrome Language Detector API is not supported.');\n\t}\n\n\tconst availability = await checkLanguageDetectorAvailability();\n\tif (availability === 'unavailable' || availability === null) {\n\t\tthrow new Error('Language Detector API is unavailable on this device.');\n\t}\n\n\tconst createOptions: any = {\n\t\t...options,\n\t\tmonitor(m: any) {\n\t\t\tif (options?.monitor) options.monitor(m);\n\t\t\ttry {\n\t\t\t\tm?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\t\tif (typeof e.loaded === 'number') {\n\t\t\t\t\t\toptions?.onProgress?.(Math.round(e.loaded * 100));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t},\n\t};\n\n\tif (typeof self === 'undefined') {\n\t\tthrow new Error('Language Detector API is not available in this environment.');\n\t}\n\tconst detector = await (self as any).LanguageDetector.create(createOptions);\n\treturn detector;\n}\n\nexport async function detectLanguages(text: string, _options?: LanguageDetectorOptions): Promise<DetectedLanguage[]> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to detect language.');\n\t}\n\n\tconst detector = await ensureLanguageDetector(_options);\n\tconst results = await detector.detect(text);\n\treturn results as DetectedLanguage[];\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/proofreader.ts",
      "content": "'use client';\n\nexport type ProofreaderAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport interface ProofreaderCreateOptions {\n\texpectedInputLanguages: string[];\n\tmonitor?: (monitor: any) => void;\n}\n\nexport interface ProofreadResultCorrection {\n\tstartIndex: number;\n\tendIndex: number;\n\t// Additional fields may exist but aren't required for our flow\n}\n\nexport interface ProofreadResult {\n\tcorrected: string;\n\tcorrections: ProofreadResultCorrection[];\n}\n\nexport function isProofreaderSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'Proofreader' in self;\n}\n\nexport async function checkProofreaderAvailability(): Promise<ProofreaderAvailability> {\n\tif (!isProofreaderSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).Proofreader.availability();\n\t\treturn status as ProofreaderAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureProofreader(options: ProofreaderCreateOptions): Promise<any> {\n\tif (!isProofreaderSupported()) {\n\t\tthrow new Error('Chrome Proofreader API is not supported.');\n\t}\n\n\tconst availability = await checkProofreaderAvailability();\n\tif (availability === 'unavailable' || availability === null) {\n\t\tthrow new Error('Proofreader API is unavailable on this device.');\n\t}\n\n\tconst createOptions: any = {\n\t\t...options,\n\t\tmonitor: (monitor: any) => {\n\t\t\tif (options.monitor) {\n\t\t\t\toptions.monitor(monitor);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmonitor?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\t\t// consumer's monitor callback receives raw monitor via options.monitor\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t},\n\t};\n\n\tif (typeof self === 'undefined') {\n\t\tthrow new Error('Proofreader API is not available in this environment.');\n\t}\n\tconst proofreader = await (self as any).Proofreader.create(createOptions);\n\treturn proofreader;\n}\n\nexport async function proofreadOnce(\n\ttext: string,\n    options: ProofreaderCreateOptions & { signal?: AbortSignal; onProgress?: (percent: number) => void }\n): Promise<ProofreadResult> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to fix grammar.');\n\t}\n\n\tconst pr = await ensureProofreader({\n\t\texpectedInputLanguages: options.expectedInputLanguages,\n\t\tmonitor: (m: any) => {\n\t\t\tm?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\tif (typeof e.loaded === 'number') {\n\t\t\t\t\toptions.onProgress?.(Math.round(e.loaded * 100));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t});\n\n\t// The Proofreader API exposes a non-streaming proofread() call (no options)\n\t// Return shape may differ: playground uses { correctedInput, corrections }\n\t// Normalize to { corrected, corrections }\n\t// @ts-ignore - runtime API shape is provided by Chrome\n\tconst raw = await pr.proofread(text);\n\tconst corrected: string = (raw?.corrected ?? raw?.correctedInput) ?? '';\n\tconst corrections: any[] = Array.isArray(raw?.corrections) ? raw.corrections : [];\n\treturn { corrected, corrections } as ProofreadResult;\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/translator.ts",
      "content": "'use client';\n\nexport type TranslatorAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport interface TranslatorOptions {\n\tsourceLanguage?: string;\n\ttargetLanguage: string;\n\tmonitor?: (monitor: any) => void;\n}\n\nexport interface TranslateOptions {\n\tsignal?: AbortSignal;\n}\n\nexport function isTranslatorSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'Translator' in self;\n}\n\nexport async function checkTranslatorAvailability(): Promise<TranslatorAvailability> {\n\tif (!isTranslatorSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).Translator.availability();\n\t\treturn status as TranslatorAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureTranslator(options: TranslatorOptions & { onProgress?: (percent: number) => void }): Promise<any> {\n    if (!isTranslatorSupported()) {\n\t\tconsole.error('Chrome Translator API is not supported.');\n        // throw new Error('Chrome Translator API is not supported.');\n        return null;\n    }\n\n    const availability = await checkTranslatorAvailability();\n    // Only hard-fail if explicitly unavailable. If null (unknown), try creating anyway.\n    if (availability === 'unavailable') {\n        throw new Error('Translator API is unavailable on this device.');\n    }\n\n    const createOptions: any = {\n        ...options,\n        monitor(m: any) {\n            if (options.monitor) options.monitor(m);\n            try {\n                m?.addEventListener?.('downloadprogress', (e: any) => {\n                    if (typeof e.loaded === 'number') {\n                        options.onProgress?.(Math.round(e.loaded * 100));\n                    }\n                });\n            } catch {}\n        },\n    };\n\n    if (typeof self === 'undefined') {\n        throw new Error('Translator API is not available in this environment.');\n    }\n    try {\n        const translator = await (self as any).Translator.create(createOptions);\n        return translator;\n    } catch (e) {\n\t\tconsole.error(`Failed to create Translator: ${(e as Error).message}`);\n        // throw new Error(`Failed to create Translator: ${(e as Error).message}`);\n        return null;\n    }\n}\n\nexport async function translateOnce(\n\ttext: string,\n\toptions: TranslatorOptions & TranslateOptions\n): Promise<string> {\n\tif (!text.trim()) {\n\t\tconsole.error('Please enter some text to translate.');\n\t\t// throw new Error('Please enter some text to translate.');\n\t\treturn '';\n\t}\n\n\tconst translator = await ensureTranslator(options);\n\tconst result = await translator.translate(text, { signal: options.signal });\n\treturn result as string;\n}\n\nexport async function* translateStreaming(\n\ttext: string,\n\toptions: TranslatorOptions & TranslateOptions\n): AsyncGenerator<string> {\n\tif (!text.trim()) {\n\t\tconsole.error('Please enter some text to translate.');\n\t\t// throw new Error('Please enter some text to translate.');\n\t\treturn;\n\t}\n\n\tconst translator = await ensureTranslator(options);\n\tif (typeof translator.translateStreaming !== 'function') {\n\t\t// Fallback to non-streaming\n\t\tyield await translator.translate(text, { signal: options.signal });\n\t\treturn;\n\t}\n\tconst stream = translator.translateStreaming(text, { signal: options.signal });\n\tlet acc = '';\n\tfor await (const chunk of stream) {\n\t\tacc += chunk;\n\t\tyield acc as string;\n\t}\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/writer.ts",
      "content": "'use client';\n\nimport type { WriterOptions, WriteOptions } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\n\nexport type WriterAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport function isWriterSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'Writer' in self;\n}\n\nexport async function checkWriterAvailability(): Promise<WriterAvailability> {\n\tif (!isWriterSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).Writer.availability();\n\t\treturn status as WriterAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureWriter(options?: WriterOptions & { onProgress?: (percent: number) => void }): Promise<any> {\n\tif (!isWriterSupported()) {\n\t\tthrow new Error('Chrome Writer API is not supported.');\n\t}\n\n\tconst availability = await checkWriterAvailability();\n\tif (availability === 'unavailable' || availability === null) {\n\t\tthrow new Error('Writer API is unavailable on this device.');\n\t}\n\n\tconst createOptions: any = {\n\t\t...options,\n\t\tmonitor: (monitor: any) => {\n\t\t\tif (options?.monitor) {\n\t\t\t\toptions.monitor(monitor);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmonitor?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\t\tif (typeof e.loaded === 'number') {\n\t\t\t\t\t\toptions?.onProgress?.(Math.round(e.loaded * 100));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t},\n\t};\n\n\tif (typeof self === 'undefined') {\n\t\tthrow new Error('Writer API is not available in this environment.');\n\t}\n\tconst writer = await (self as any).Writer.create(createOptions);\n\treturn writer;\n}\n\nexport async function writeOnce(\n\tprompt: string,\n\toptions?: (WriterOptions & { onProgress?: (percent: number) => void }) & WriteOptions\n): Promise<string> {\n\tif (!prompt.trim()) {\n\t\tthrow new Error('Please enter a prompt to write content.');\n\t}\n\n\tconst writer = await ensureWriter(options);\n\tconst result = await writer.write(prompt, { context: options?.context });\n\treturn result as string;\n}\n\nexport async function* writeStreaming(\n\tprompt: string,\n\toptions?: (WriterOptions & { signal?: AbortSignal; onProgress?: (percent: number) => void }) & WriteOptions\n): AsyncGenerator<string> {\n\tif (!prompt.trim()) {\n\t\tthrow new Error('Please enter a prompt to write content.');\n\t}\n\n\tconst writer = await ensureWriter(options);\n\tconst stream = writer.writeStreaming(prompt, { context: options?.context, signal: options?.signal });\n\tlet acc = '';\n\tfor await (const chunk of stream) {\n\t\tacc += chunk;\n\t\tyield acc as string;\n\t}\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/rewriter.ts",
      "content": "'use client';\n\nimport type { RewriterOptions, RewriteOptions } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\n\nexport type RewriterAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport function isRewriterSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'Rewriter' in self;\n}\n\nexport async function checkRewriterAvailability(): Promise<RewriterAvailability> {\n\tif (!isRewriterSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).Rewriter.availability();\n\t\treturn status as RewriterAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureRewriter(options?: RewriterOptions & { onProgress?: (percent: number) => void }): Promise<any> {\n\tif (!isRewriterSupported()) {\n\t\tthrow new Error('Chrome Rewriter API is not supported.');\n\t}\n\n\tconst availability = await checkRewriterAvailability();\n\tif (availability === 'unavailable' || availability === null) {\n\t\tthrow new Error('Rewriter API is unavailable on this device.');\n\t}\n\n\tconst createOptions: any = {\n\t\t...options,\n\t\tmonitor: (monitor: any) => {\n\t\t\tif (options?.monitor) {\n\t\t\t\toptions.monitor(monitor);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmonitor?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\t\tif (typeof e.loaded === 'number') {\n\t\t\t\t\t\toptions?.onProgress?.(Math.round(e.loaded * 100));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t},\n\t};\n\n\tif (typeof self === 'undefined') {\n\t\tthrow new Error('Rewriter API is not available in this environment.');\n\t}\n\tconst rewriter = await (self as any).Rewriter.create(createOptions);\n\treturn rewriter;\n}\n\nexport async function rewriteOnce(\n\ttext: string,\n\toptions?: (RewriterOptions & { onProgress?: (percent: number) => void }) & RewriteOptions\n): Promise<string> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to improve.');\n\t}\n\n\tconst rewriter = await ensureRewriter(options);\n\tconst result = await rewriter.rewrite(text, { context: options?.context, signal: options?.signal });\n\treturn result as string;\n}\n\nexport async function* rewriteStreaming(\n\ttext: string,\n\toptions?: (RewriterOptions & { signal?: AbortSignal; onProgress?: (percent: number) => void }) & RewriteOptions\n): AsyncGenerator<string> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to improve.');\n\t}\n\n\tconst rewriter = await ensureRewriter(options);\n\tconst stream = rewriter.rewriteStreaming(text, { context: options?.context, signal: options?.signal });\n\tlet acc = '';\n\tfor await (const chunk of stream) {\n\t\tacc += chunk;\n\t\tyield acc as string;\n\t}\n}\n\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/gencn-ui/items/shared/lib/summarizer.ts",
      "content": "'use client';\n\nimport type { SummarizerOptions, SummarizeOptions } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\n\nexport type SummarizerAvailability = 'available' | 'downloadable' | 'unavailable' | null;\n\nexport function isSummarizerSupported(): boolean {\n\tif (typeof self === 'undefined') return false;\n\treturn 'Summarizer' in self;\n}\n\nexport async function checkSummarizerAvailability(): Promise<SummarizerAvailability> {\n\tif (!isSummarizerSupported()) return null;\n\tif (typeof self === 'undefined') return null;\n\ttry {\n\t\tconst status = await (self as any).Summarizer.availability();\n\t\treturn status as SummarizerAvailability;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport async function ensureSummarizer(options?: SummarizerOptions & { onProgress?: (percent: number) => void }): Promise<any> {\n\tif (!isSummarizerSupported()) {\n\t\tthrow new Error('Chrome Summarizer API is not supported.');\n\t}\n\n\tconst availability = await checkSummarizerAvailability();\n\tif (availability === 'unavailable' || availability === null) {\n\t\tthrow new Error('Summarizer API is unavailable on this device.');\n\t}\n\n\tconst createOptions: any = {\n\t\t...options,\n\t\tmonitor: (monitor: any) => {\n\t\t\tif (options?.monitor) {\n\t\t\t\toptions.monitor(monitor);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmonitor?.addEventListener?.('downloadprogress', (e: any) => {\n\t\t\t\t\tif (typeof e.loaded === 'number') {\n\t\t\t\t\t\toptions?.onProgress?.(Math.round(e.loaded * 100));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t},\n\t};\n\n\tif (typeof self === 'undefined') {\n\t\tthrow new Error('Summarizer API is not available in this environment.');\n\t}\n\tconst summarizer = await (self as any).Summarizer.create(createOptions);\n\treturn summarizer;\n}\n\nexport async function summarizeOnce(\n\ttext: string,\n\toptions?: (SummarizerOptions & { onProgress?: (percent: number) => void }) & SummarizeOptions\n): Promise<string> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to summarize.');\n\t}\n\n\tconst summarizer = await ensureSummarizer(options);\n\tconst result = await summarizer.summarize(text, { context: options?.context });\n\treturn result as string;\n}\n\nexport async function* summarizeStreaming(\n\ttext: string,\n\toptions?: (SummarizerOptions & { signal?: AbortSignal; onProgress?: (percent: number) => void }) & SummarizeOptions\n): AsyncGenerator<string> {\n\tif (!text.trim()) {\n\t\tthrow new Error('Please enter some text to summarize.');\n\t}\n\n\tconst summarizer = await ensureSummarizer(options);\n\tconst stream = summarizer.summarizeStreaming(text, { context: options?.context, signal: options?.signal });\n\tlet acc = '';\n\tfor await (const chunk of stream) {\n\t\tacc += chunk;\n\t\tyield acc as string;\n\t}\n}",
      "type": "registry:lib"
    }
  ]
}