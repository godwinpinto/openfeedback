{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-provider",
  "type": "registry:component",
  "title": "GUI Provider",
  "description": "Provider component for Chrome AI APIs (Summarizer, Writer, Rewriter, Language Detector).",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/genui-summarize-selection.json"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/shared/genui-provider.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { SummarizeSelection } from \"./genui-summarize-selection\";\nimport {\n  SummarizeOptions,\n  SummarizerOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\nimport {\n  WriterOptions,\n  RewriterOptions,\n  WriteOptions,\n  RewriteOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\n\n// Type definitions for Chrome Language Detector API\nexport interface LanguageDetectorOptions {\n  monitor?: (monitor: any) => void;\n}\n\nexport interface DetectedLanguage {\n  detectedLanguage: string;\n  confidence: number;\n}\n\nexport type AvailabilityStatus =\n  | \"available\"\n  | \"downloadable\"\n  | \"unavailable\"\n  | null;\n\n// LanguageModel Prompt API types\nexport interface PromptOptions {\n  temperature?: number;\n  topK?: number;\n  responseConstraint?: any; // JSON Schema for structured output\n  omitResponseConstraintInput?: boolean;\n  signal?: AbortSignal;\n}\n\nexport interface LanguageModelAvailabilityStatus {\n  // State\n  isLanguageModelSupported: boolean | null;\n  languageModelAvailability: AvailabilityStatus;\n  languageModelError: string | null;\n\n  // Functions\n  checkLanguageModelAvailability: (\n    options?: PromptOptions\n  ) => Promise<AvailabilityStatus>;\n}\n\nexport interface GenUIContextValue extends LanguageModelAvailabilityStatus {\n  // State\n  isSupported: boolean | null;\n  isWriterSupported: boolean | null;\n  isRewriterSupported: boolean | null;\n  isLanguageDetectorSupported: boolean | null;\n  availability: AvailabilityStatus;\n  writerAvailability: AvailabilityStatus;\n  rewriterAvailability: AvailabilityStatus;\n  languageDetectorAvailability: AvailabilityStatus;\n  downloadProgress: number;\n  writerDownloadProgress: number;\n  rewriterDownloadProgress: number;\n  languageDetectorDownloadProgress: number;\n  isDownloading: boolean;\n  isWriterDownloading: boolean;\n  isRewriterDownloading: boolean;\n  isLanguageDetectorDownloading: boolean;\n  error: string | null;\n\n  // Functions\n  checkAvailability: () => Promise<AvailabilityStatus>;\n  checkWriterAvailability: () => Promise<AvailabilityStatus>;\n  checkRewriterAvailability: () => Promise<AvailabilityStatus>;\n  checkLanguageDetectorAvailability: () => Promise<AvailabilityStatus>;\n  createSummarizer: (options?: SummarizerOptions) => Promise<any>;\n  createWriter: (options?: WriterOptions) => Promise<any>;\n  createRewriter: (options?: RewriterOptions) => Promise<any>;\n  createLanguageDetector: (options?: LanguageDetectorOptions) => Promise<any>;\n  summarize: (\n    text: string,\n    options?: SummarizeOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  write: (\n    prompt: string,\n    options?: WriteOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  rewrite: (\n    text: string,\n    options?: RewriteOptions & {\n      streaming?: boolean;\n      onChunk?: (chunk: string) => void;\n    }\n  ) => Promise<string>;\n  detectLanguage: (text: string) => Promise<DetectedLanguage[]>;\n  resetError: () => void;\n}\n\nconst GenUIContext = React.createContext<GenUIContextValue | undefined>(\n  undefined\n);\n\nexport interface GenUIProviderProps {\n  children: React.ReactNode;\n  defaultOptions?: SummarizerOptions;\n  defaultWriterOptions?: WriterOptions;\n  defaultRewriterOptions?: RewriterOptions;\n  defaultLanguageDetectorOptions?: LanguageDetectorOptions;\n  enableSelectionSummarizer?: boolean;\n}\n\nexport function GenUIProvider({\n  children,\n  defaultOptions,\n  defaultWriterOptions,\n  defaultLanguageDetectorOptions,\n  defaultRewriterOptions,\n  enableSelectionSummarizer = false,\n}: GenUIProviderProps) {\n  const [isSupported, setIsSupported] = React.useState<boolean | null>(null);\n  const [isWriterSupported, setIsWriterSupported] = React.useState<\n    boolean | null\n  >(null);\n  const [isRewriterSupported, setIsRewriterSupported] = React.useState<\n    boolean | null\n  >(null);\n  const [isLanguageDetectorSupported, setIsLanguageDetectorSupported] =\n    React.useState<boolean | null>(null);\n  const [availability, setAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [writerAvailability, setWriterAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [rewriterAvailability, setRewriterAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [languageDetectorAvailability, setLanguageDetectorAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [downloadProgress, setDownloadProgress] = React.useState(0);\n  const [writerDownloadProgress, setWriterDownloadProgress] = React.useState(0);\n  const [rewriterDownloadProgress, setRewriterDownloadProgress] =\n    React.useState(0);\n  const [\n    languageDetectorDownloadProgress,\n    setLanguageDetectorDownloadProgress,\n  ] = React.useState(0);\n  const [isDownloading, setIsDownloading] = React.useState(false);\n  const [isWriterDownloading, setIsWriterDownloading] = React.useState(false);\n  const [isRewriterDownloading, setIsRewriterDownloading] =\n    React.useState(false);\n  const [isLanguageDetectorDownloading, setIsLanguageDetectorDownloading] =\n    React.useState(false);\n  const [error, setError] = React.useState<string | null>(null);\n  const hasCheckedAvailability = React.useRef(false);\n  const hasCheckedWriterAvailability = React.useRef(false);\n  const hasCheckedRewriterAvailability = React.useRef(false);\n  const hasCheckedLanguageDetectorAvailability = React.useRef(false);\n\n  // LanguageModel Prompt API state\n  const [isLanguageModelSupported, setIsLanguageModelSupported] =\n    React.useState<boolean | null>(null);\n  const [languageModelAvailability, setLanguageModelAvailability] =\n    React.useState<AvailabilityStatus>(null);\n  const [languageModelError, setLanguageModelError] = React.useState<\n    string | null\n  >(null);\n  const hasCheckedLanguageModelAvailability = React.useRef(false);\n\n  // Check if Chrome Summarizer API is supported\n  React.useEffect(() => {\n    const checkSupport = () => {\n      const hasSummarizer = \"Summarizer\" in self;\n      const hasWriter = \"Writer\" in self;\n      const hasLanguageDetector = \"LanguageDetector\" in self;\n      const hasRewriter = \"Rewriter\" in self;\n\n      setIsSupported(hasSummarizer);\n      setIsWriterSupported(hasWriter);\n      setIsRewriterSupported(hasRewriter);\n      setIsLanguageDetectorSupported(hasLanguageDetector);\n\n      if (\n        !hasSummarizer &&\n        !hasWriter &&\n        !hasRewriter &&\n        !hasLanguageDetector\n      ) {\n        const errorMsg =\n          \"Chrome AI APIs are not supported in this browser. Please use Chrome 137+ with the required hardware specifications.\";\n        setError(errorMsg);\n      }\n    };\n\n    checkSupport();\n  }, []);\n\n  // Check if Chrome LanguageModel Prompt API is supported\n  React.useEffect(() => {\n    const checkLanguageModelSupport = () => {\n      if (\"LanguageModel\" in self) {\n        setIsLanguageModelSupported(true);\n      } else {\n        setIsLanguageModelSupported(false);\n        const errorMsg =\n          \"Chrome Prompt API (LanguageModel) is not supported in this browser. Please use Chrome 138+ with the required hardware specifications.\";\n        setLanguageModelError(errorMsg);\n      }\n    };\n\n    checkLanguageModelSupport();\n  }, []);\n\n  // Check model availability\n  const checkAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (\n          self as any\n        ).Summarizer.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Summarizer API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsDownloading(true);\n          setDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check summarizer availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setAvailability(null);\n        return null;\n      }\n    }, [isSupported]);\n\n  // Check Writer model availability\n  const checkWriterAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (self as any).Writer.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Writer API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setWriterAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setWriterAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsWriterDownloading(true);\n          setWriterDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check writer availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setWriterAvailability(null);\n        return null;\n      }\n    }, [isWriterSupported]);\n\n  // Automatically check availability when support is confirmed\n  React.useEffect(() => {\n    if (isSupported === true && !hasCheckedAvailability.current) {\n      hasCheckedAvailability.current = true;\n      checkAvailability();\n    }\n  }, [isSupported, checkAvailability]);\n\n  // Check Language Detector model availability\n  const checkLanguageDetectorAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (\n          self as any\n        ).LanguageDetector.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Language Detector API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setLanguageDetectorAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setLanguageDetectorAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsLanguageDetectorDownloading(true);\n          setLanguageDetectorDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check language detector availability: \" +\n          (err as Error).message;\n        setError(errorMsg);\n        setLanguageDetectorAvailability(null);\n        return null;\n      }\n    }, [isLanguageDetectorSupported]);\n\n  // Automatically check writer availability when support is confirmed\n  React.useEffect(() => {\n    if (isWriterSupported === true && !hasCheckedWriterAvailability.current) {\n      hasCheckedWriterAvailability.current = true;\n      checkWriterAvailability();\n    }\n  }, [isWriterSupported, checkWriterAvailability]);\n\n  // Check Rewriter model availability\n  const checkRewriterAvailability =\n    React.useCallback(async (): Promise<AvailabilityStatus> => {\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const availabilityStatus = await (self as any).Rewriter.availability();\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Rewriter API is not available on this device. Please check hardware requirements.\";\n          setError(errorMsg);\n          setRewriterAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setRewriterAvailability(availabilityStatus);\n        setError(null);\n\n        if (availabilityStatus === \"downloadable\") {\n          setIsRewriterDownloading(true);\n          setRewriterDownloadProgress(0);\n        }\n\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check rewriter availability: \" + (err as Error).message;\n        setError(errorMsg);\n        setRewriterAvailability(null);\n        return null;\n      }\n    }, [isRewriterSupported]);\n\n  // Automatically check rewriter availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isRewriterSupported === true &&\n      !hasCheckedRewriterAvailability.current\n    ) {\n      hasCheckedRewriterAvailability.current = true;\n      checkRewriterAvailability();\n    }\n  }, [isRewriterSupported, checkRewriterAvailability]);\n\n  // Automatically check language detector availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isLanguageDetectorSupported === true &&\n      !hasCheckedLanguageDetectorAvailability.current\n    ) {\n      hasCheckedLanguageDetectorAvailability.current = true;\n      checkLanguageDetectorAvailability();\n    }\n  }, [isLanguageDetectorSupported, checkLanguageDetectorAvailability]);\n\n  // Create summarizer instance\n  const createSummarizer = React.useCallback(\n    async (options?: SummarizerOptions): Promise<any> => {\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const summarizerOptions: SummarizerOptions = {\n          ...defaultOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setDownloadProgress(progress);\n            });\n          },\n        };\n\n        const summarizer = await (self as any).Summarizer.create(\n          summarizerOptions\n        );\n        setIsDownloading(false);\n        setDownloadProgress(100);\n        setError(null);\n        return summarizer;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to create summarizer: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsDownloading(false);\n        return null;\n      }\n    },\n    [isSupported, defaultOptions]\n  );\n\n  // Summarize function (batch or streaming)\n  const summarize = React.useCallback(\n    async (\n      text: string,\n      options?: SummarizeOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to summarize.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isSupported) {\n        const errorMsg = \"Chrome Summarizer API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Summarizer is not available.\");\n        }\n\n        // Create summarizer\n        const summarizer = await createSummarizer();\n        if (!summarizer) {\n          throw new Error(\"Failed to create summarizer.\");\n        }\n\n        const summarizeOptions: SummarizeOptions = {\n          context:\n            options?.context ||\n            defaultOptions?.sharedContext ||\n            \"This text is being summarized for better understanding.\",\n        };\n\n        // Perform summarization\n        if (options?.streaming) {\n          const stream = summarizer.summarizeStreaming(text, summarizeOptions);\n          let result = \"\";\n\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n\n          return result;\n        } else {\n          const result = await summarizer.summarize(text, summarizeOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [isSupported, checkAvailability, createSummarizer, defaultOptions]\n  );\n\n  // Create writer instance\n  const createWriter = React.useCallback(\n    async (options?: WriterOptions): Promise<any> => {\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const writerOptions: WriterOptions = {\n          ...defaultWriterOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setWriterDownloadProgress(progress);\n            });\n          },\n        };\n\n        const writer = await (self as any).Writer.create(writerOptions);\n        setIsWriterDownloading(false);\n        setWriterDownloadProgress(100);\n        setError(null);\n        return writer;\n      } catch (err) {\n        const errorMsg = \"Failed to create writer: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsWriterDownloading(false);\n        return null;\n      }\n    },\n    [isWriterSupported, defaultWriterOptions]\n  );\n\n  // Write function (batch or streaming)\n  const write = React.useCallback(\n    async (\n      prompt: string,\n      options?: WriteOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!prompt.trim()) {\n        const errorMsg = \"Please enter a prompt to write content.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isWriterSupported) {\n        const errorMsg = \"Chrome Writer API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkWriterAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Writer is not available.\");\n        }\n\n        // Create writer\n        const writer = await createWriter();\n        if (!writer) {\n          throw new Error(\"Failed to create writer.\");\n        }\n\n        const writeOptions: WriteOptions = {\n          context:\n            options?.context ||\n            defaultWriterOptions?.sharedContext ||\n            \"Generate helpful and appropriate content.\",\n        };\n\n        // Perform writing\n        if (options?.streaming) {\n          const stream = writer.writeStreaming(prompt, writeOptions);\n          let result = \"\";\n\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n\n          return result;\n        } else {\n          const result = await writer.write(prompt, writeOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isWriterSupported,\n      checkWriterAvailability,\n      createWriter,\n      defaultWriterOptions,\n    ]\n  );\n\n  // Create rewriter instance\n  const createRewriter = React.useCallback(\n    async (options?: RewriterOptions): Promise<any> => {\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const rewriterOptions: RewriterOptions = {\n          ...defaultRewriterOptions,\n          ...options,\n          monitor: (monitor) => {\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setRewriterDownloadProgress(progress);\n            });\n          },\n        };\n\n        const rewriter = await (self as any).Rewriter.create(rewriterOptions);\n        setIsRewriterDownloading(false);\n        setRewriterDownloadProgress(100);\n        setError(null);\n        return rewriter;\n      } catch (err) {\n        const errorMsg = \"Failed to create rewriter: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsRewriterDownloading(false);\n        return null;\n      }\n    },\n    [isRewriterSupported, defaultRewriterOptions]\n  );\n\n  // Rewrite function (batch or streaming)\n  const rewrite = React.useCallback(\n    async (\n      text: string,\n      options?: RewriteOptions & {\n        streaming?: boolean;\n        onChunk?: (chunk: string) => void;\n      }\n    ): Promise<string> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to improve.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isRewriterSupported) {\n        const errorMsg = \"Chrome Rewriter API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        const availabilityStatus = await checkRewriterAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Rewriter is not available.\");\n        }\n\n        const rewriter = await createRewriter();\n        if (!rewriter) {\n          throw new Error(\"Failed to create rewriter.\");\n        }\n\n        const rewriteOptions: RewriteOptions = {\n          context:\n            options?.context ||\n            defaultRewriterOptions?.sharedContext ||\n            \"Improve clarity and readability without changing meaning.\",\n          signal: options?.signal,\n        };\n\n        if (options?.streaming) {\n          const stream = rewriter.rewriteStreaming(text, rewriteOptions);\n          let result = \"\";\n          for await (const chunk of stream) {\n            result += chunk;\n            options?.onChunk?.(result);\n          }\n          return result;\n        } else {\n          const result = await rewriter.rewrite(text, rewriteOptions);\n          return result;\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isRewriterSupported,\n      checkRewriterAvailability,\n      createRewriter,\n      defaultRewriterOptions,\n    ]\n  );\n\n  // Create language detector instance\n  const createLanguageDetector = React.useCallback(\n    async (options?: LanguageDetectorOptions): Promise<any> => {\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        return null;\n      }\n\n      try {\n        const detectorOptions: LanguageDetectorOptions = {\n          ...defaultLanguageDetectorOptions,\n          ...options,\n          monitor: (monitor) => {\n            // Merge with user-provided monitor if exists\n            if (options?.monitor) {\n              options.monitor(monitor);\n            }\n\n            monitor.addEventListener(\"downloadprogress\", (e: any) => {\n              const progress = e.loaded * 100;\n              setLanguageDetectorDownloadProgress(progress);\n            });\n          },\n        };\n\n        const detector = await (self as any).LanguageDetector.create(\n          detectorOptions\n        );\n        setIsLanguageDetectorDownloading(false);\n        setLanguageDetectorDownloadProgress(100);\n        setError(null);\n        return detector;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to create language detector: \" + (err as Error).message;\n        setError(errorMsg);\n        setIsLanguageDetectorDownloading(false);\n        return null;\n      }\n    },\n    [isLanguageDetectorSupported, defaultLanguageDetectorOptions]\n  );\n\n  // Detect language function\n  const detectLanguage = React.useCallback(\n    async (text: string): Promise<DetectedLanguage[]> => {\n      if (!text.trim()) {\n        const errorMsg = \"Please enter some text to detect language.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      if (!isLanguageDetectorSupported) {\n        const errorMsg = \"Chrome Language Detector API is not supported.\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      try {\n        // Check availability first\n        const availabilityStatus = await checkLanguageDetectorAvailability();\n        if (\n          availabilityStatus === \"unavailable\" ||\n          availabilityStatus === null\n        ) {\n          throw new Error(\"Language Detector is not available.\");\n        }\n\n        // Create language detector\n        const detector = await createLanguageDetector();\n        if (!detector) {\n          throw new Error(\"Failed to create language detector.\");\n        }\n\n        // Perform language detection\n        const results = await detector.detect(text);\n        return results;\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        setError(errorMsg);\n        throw err;\n      }\n    },\n    [\n      isLanguageDetectorSupported,\n      checkLanguageDetectorAvailability,\n      createLanguageDetector,\n    ]\n  );\n\n  // Check LanguageModel availability\n  const checkLanguageModelAvailability = React.useCallback(\n    async (options?: PromptOptions): Promise<AvailabilityStatus> => {\n      if (!isLanguageModelSupported) {\n        const errorMsg = \"Chrome Prompt API (LanguageModel) is not supported.\";\n        setLanguageModelError(errorMsg);\n        return null;\n      }\n      try {\n        // Always pass the same options to availability() that will be used in prompt()\n        const availabilityStatus = await (\n          self as any\n        ).LanguageModel.availability(options);\n\n        if (availabilityStatus === \"unavailable\") {\n          const errorMsg =\n            \"Prompt API (LanguageModel) is not available on this device. Please check hardware requirements.\";\n          setLanguageModelError(errorMsg);\n          setLanguageModelAvailability(\"unavailable\");\n          return \"unavailable\";\n        }\n\n        setLanguageModelAvailability(availabilityStatus);\n        setLanguageModelError(null);\n        return availabilityStatus;\n      } catch (err) {\n        const errorMsg =\n          \"Failed to check LanguageModel availability: \" +\n          (err as Error).message;\n        setLanguageModelError(errorMsg);\n        setLanguageModelAvailability(null);\n        return null;\n      }\n    },\n    [isLanguageModelSupported]\n  );\n\n  // Automatically check LanguageModel availability when support is confirmed\n  React.useEffect(() => {\n    if (\n      isLanguageModelSupported === true &&\n      !hasCheckedLanguageModelAvailability.current\n    ) {\n      hasCheckedLanguageModelAvailability.current = true;\n      checkLanguageModelAvailability();\n    }\n  }, [isLanguageModelSupported, checkLanguageModelAvailability]);\n\n  // Reset error\n  const resetError = React.useCallback(() => {\n    setError(null);\n  }, []);\n\n  const value: GenUIContextValue = React.useMemo(\n    () => ({\n      // Summarizer API\n      isSupported,\n      isWriterSupported,\n      isRewriterSupported,\n      isLanguageDetectorSupported,\n      availability,\n      writerAvailability,\n      rewriterAvailability,\n      languageDetectorAvailability,\n      downloadProgress,\n      writerDownloadProgress,\n      rewriterDownloadProgress,\n      languageDetectorDownloadProgress,\n      isDownloading,\n      isWriterDownloading,\n      isRewriterDownloading,\n      isLanguageDetectorDownloading,\n      error,\n      checkAvailability,\n      checkWriterAvailability,\n      checkRewriterAvailability,\n      checkLanguageDetectorAvailability,\n      createSummarizer,\n      createWriter,\n      createRewriter,\n      createLanguageDetector,\n      summarize,\n      write,\n      rewrite,\n      detectLanguage,\n      resetError,\n      // LanguageModel Prompt API\n      isLanguageModelSupported,\n      languageModelAvailability,\n      languageModelError,\n      checkLanguageModelAvailability,\n    }),\n    [\n      isSupported,\n      isWriterSupported,\n      isRewriterSupported,\n      isLanguageDetectorSupported,\n      availability,\n      writerAvailability,\n      rewriterAvailability,\n      languageDetectorAvailability,\n      downloadProgress,\n      writerDownloadProgress,\n      rewriterDownloadProgress,\n      languageDetectorDownloadProgress,\n      isDownloading,\n      isWriterDownloading,\n      isRewriterDownloading,\n      isLanguageDetectorDownloading,\n      error,\n      checkAvailability,\n      checkWriterAvailability,\n      checkRewriterAvailability,\n      checkLanguageDetectorAvailability,\n      createSummarizer,\n      createWriter,\n      createRewriter,\n      createLanguageDetector,\n      summarize,\n      write,\n      rewrite,\n      detectLanguage,\n      resetError,\n      isLanguageModelSupported,\n      languageModelAvailability,\n      languageModelError,\n      checkLanguageModelAvailability,\n    ]\n  );\n\n  return (\n    <GenUIContext.Provider value={value}>\n      {children}\n      {enableSelectionSummarizer ? (\n        // Lazy import to avoid SSR issues if any consumer renders on server\n        <SummarizeSelection defaultOptions={defaultOptions} />\n      ) : null}\n    </GenUIContext.Provider>\n  );\n}\n\n// Hook to use Voiceable context\nexport function useGenUI(): GenUIContextValue {\n  const context = React.useContext(GenUIContext);\n  if (context === undefined) {\n    throw new Error(\"useGenUI must be used within a GenUIProvider\");\n  }\n  return context;\n}\n",
      "type": "registry:block"
    }
  ]
}