{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-textarea",
  "type": "registry:component",
  "title": "GenUI Textarea",
  "description": "GenUI-powered textarea component with automatic text rewriting and tone customization.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/genui-provider.json",
    "textarea",
    "input",
    "button",
    "spinner",
    "dropdown-menu",
    "dialog",
    "alert",
    "select",
    "command",
    "popover"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/textarea/genui-textarea.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { Sparkles, Wand2, Languages, Repeat2, SpellCheck } from 'lucide-react';\nimport {\n  Textarea,\n} from '@/components/ui/textarea';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Spinner } from '@/components/ui/spinner';\nimport { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@/components/ui/dropdown-menu';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\nimport { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from '@/components/ui/select';\nimport { type SummarizerOptions, type DetectedLanguage, type RewriterOptions } from '@/registry/new-york/gencn-ui/items/shared/genui-types';\nimport { proofreadOnce } from '@/registry/new-york/gencn-ui/items/shared/lib/proofreader';\nimport { isSummarizerSupported, checkSummarizerAvailability, ensureSummarizer } from '@/registry/new-york/gencn-ui/items/shared/lib/summarizer';\nimport { isWriterSupported as svcIsWriterSupported, checkWriterAvailability as svcCheckWriterAvailability, ensureWriter as svcEnsureWriter } from '@/registry/new-york/gencn-ui/items/shared/lib/writer';\nimport { isRewriterSupported as svcIsRewriterSupported, checkRewriterAvailability as svcCheckRewriterAvailability, ensureRewriter as svcEnsureRewriter } from '@/registry/new-york/gencn-ui/items/shared/lib/rewriter';\nimport { detectLanguages } from '@/registry/new-york/gencn-ui/items/shared/lib/language-detector';\nimport { ensureTranslator } from '@/registry/new-york/gencn-ui/items/shared/lib/translator';\nimport { Input } from '@/components/ui/input';\n\nexport type ButtonVisibility = 'ALWAYS' | 'ON_FOCUS';\n\nexport interface GenUITextareaProps extends React.ComponentProps<'textarea'> {\n  /**\n   * Controls when the summarize button is visible\n   * - ALWAYS: Button is always visible\n   * - ON_FOCUS: Button only appears when the textarea is focused\n   */\n  buttonVisibility?: ButtonVisibility;\n  \n  /**\n   * Custom content for the summarize button (JSX)\n   * If not provided, defaults to a Sparkles icon\n   */\n  buttonContent?: React.ReactNode;\n  \n  /**\n   * Callback function when the summarize button is clicked\n   * Called after summarization completes with both the original text and summary\n   */\n  onSummarize?: (text: string, summary?: string) => void;\n  \n  /**\n   * Summary type for Chrome AI\n   */\n  summaryType?: 'key-points' | 'tldr' | 'teaser' | 'headline';\n  \n  /**\n   * Summary length for Chrome AI\n   */\n  summaryLength?: 'short' | 'medium' | 'long';\n  \n  /**\n   * Summary format for Chrome AI\n   */\n  summaryFormat?: 'markdown' | 'plain-text';\n  \n  /**\n   * Enable streaming for Chrome AI summarization\n   */\n  enableStreaming?: boolean;\n  \n  /**\n   * Shared context for Chrome AI summarization\n   */\n  sharedContext?: string;\n  \n  /**\n   * Callback when summary is generated\n   */\n  onSummaryGenerated?: (summary: string) => void;\n  \n  /**\n   * Callback when summarization error occurs\n   */\n  onSummaryError?: (error: string) => void;\n  \n  /**\n   * Additional className for the wrapper container\n   */\n  containerClassName?: string;\n  \n  /**\n   * Additional className for the button\n   */\n  buttonClassName?: string;\n\n  /**\n  * AI Features to enable (marketing-friendly names)\n   * - compose (Writer API)\n   * - improve (Rewriter API - future)\n   * - fix-grammar (Proofreader API - future)\n   * - translate (Translator API - future)\n  * - inline-suggest (Rewriter API inline suggestions)\n   */\n  features?: Array<'compose' | 'improve' | 'fix-grammar' | 'translate' | 'inline-suggest'>;\n\n  /**\n   * List of target languages (BCP 47 codes) offered for translation\n   * Example: ['en', 'fr', 'es', 'de']\n   */\n  translateTargets?: string[];\n\n  /**\n   * Optional map from BCP 47 code to human-readable label for dropdown\n   * Example: { en: 'English', fr: 'French' }\n   */\n  translateLanguageMap?: Record<string, string>;\n\n  /**\n   * Placeholder for the prompt input in the compose modal\n   */\n  placeholderPrompt?: string;\n\n  /**\n   * Writer options passed to Writer.create\n   */\n  writerOptions?: {\n    tone?: 'formal' | 'neutral' | 'casual';\n    format?: 'markdown' | 'plain-text';\n    length?: 'short' | 'medium' | 'long';\n    sharedContext?: string;\n    expectedInputLanguages?: string[];\n    expectedContextLanguages?: string[];\n    outputLanguage?: string;\n  };\n\n  /**\n   * Called when AI result is accepted and applied to textarea\n   */\n  onAccept?: (text: string) => void;\n\n  /**\n   * Called when any AI flow errors\n   */\n  onAIError?: (error: Error) => void;\n\n  /**\n   * Inline auto-suggestion (Rewriter) configuration\n   */\n  autoSuggestEnabled?: boolean;\n  autoSuggestDebounceMs?: number;\n  autoSuggestMaxChars?: number;\n  autoSuggestPrompt?: string;\n}\n\nexport const GenUITextarea = React.forwardRef<HTMLTextAreaElement, GenUITextareaProps>(\n  (\n    {\n      buttonVisibility = 'ALWAYS',\n      buttonContent,\n      onSummarize,\n      summaryType = 'key-points',\n      summaryLength = 'medium',\n      summaryFormat = 'markdown',\n      enableStreaming = false,\n      sharedContext = '',\n      onSummaryGenerated,\n      onSummaryError,\n      containerClassName,\n      buttonClassName,\n      className,\n      onFocus,\n      onBlur,\n      features,\n      translateTargets,\n      translateLanguageMap,\n      placeholderPrompt,\n      writerOptions,\n      onAccept,\n      onAIError,\n      autoSuggestEnabled,\n      autoSuggestDebounceMs = 500,\n      autoSuggestMaxChars = 48,\n      autoSuggestPrompt,\n      ...props\n    },\n    ref\n  ) => {\n    const [isFocused, setIsFocused] = React.useState(false);\n    const [isLoading, setIsLoading] = React.useState(false);\n    const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n\n    // AI Feature UI state\n    const [isFeatureOpen, setIsFeatureOpen] = React.useState(false);\n    const [activeFeature, setActiveFeature] = React.useState<\n      'compose' | 'improve' | 'fix-grammar' | 'translate' | null\n    >(null);\n    const [phase, setPhase] = React.useState<'prompt' | 'generating' | 'result'>('prompt');\n    const [promptText, setPromptText] = React.useState('');\n    const [resultText, setResultText] = React.useState('');\n    const [aiError, setAiError] = React.useState<string | null>(null);\n    const [downloadProgress, setDownloadProgress] = React.useState<number | null>(null);\n    const [detected, setDetected] = React.useState<DetectedLanguage[] | null>(null);\n    const [selectedTarget, setSelectedTarget] = React.useState<string>('');\n    const abortRef = React.useRef<AbortController | null>(null);\n    const writerRef = React.useRef<any>(null);\n    const rewriterRef = React.useRef<any>(null);\n    const suggestAbortRef = React.useRef<AbortController | null>(null);\n    const suggestTimeoutRef = React.useRef<any>(null);\n\n    // Auto-suggest UI state\n    const [suggestedText, setSuggestedText] = React.useState('');\n    const [isSuggesting, setIsSuggesting] = React.useState(false);\n    const mirrorRef = React.useRef<HTMLDivElement | null>(null);\n    const markerRef = React.useRef<HTMLSpanElement | null>(null);\n    const [caretPos, setCaretPos] = React.useState<{\n      top: number;\n      left: number;\n      lineHeight: number;\n      containerWidth: number;\n      fontFamily: string;\n      fontSize: string;\n      fontWeight: string;\n      letterSpacing: string;\n      lineHeightCss: string;\n    }>({ top: 0, left: 0, lineHeight: 0, containerWidth: 0, fontFamily: '', fontSize: '', fontWeight: '', letterSpacing: '', lineHeightCss: '' });\n    \n    // Support flags via services\n    const isSupported = isSummarizerSupported();\n    const isWriterSupported = svcIsWriterSupported();\n    const isRewriterSupported = svcIsRewriterSupported();\n    \n    // Merge refs: internal ref and forwarded ref\n    React.useImperativeHandle(ref, () => textareaRef.current as HTMLTextAreaElement, []);\n\n    // Report errors to parent component when Chrome AI is not supported\n    React.useEffect(() => {\n      if (isSupported === false) {\n        onSummaryError?.('Chrome Summarizer API is not supported in this browser. Please use Chrome 138+ with the required hardware specifications.');\n      }\n    }, [isSupported, onSummaryError]);\n\n    const handleFocus = React.useCallback(\n      (e: React.FocusEvent<HTMLTextAreaElement>) => {\n        setIsFocused(true);\n        onFocus?.(e);\n      },\n      [onFocus]\n    );\n\n    const handleBlur = React.useCallback(\n      (e: React.FocusEvent<HTMLTextAreaElement>) => {\n        setIsFocused(false);\n        onBlur?.(e);\n      },\n      [onBlur]\n    );\n\n    // ============ Writer API (Compose) ============\n    const ensureWriter = React.useCallback(async () => {\n      try {\n        if (!isWriterSupported) {\n          throw new Error('Chrome Writer API is not supported.');\n        }\n\n        const avail = await svcCheckWriterAvailability();\n        if (avail === 'unavailable' || avail === null) {\n          throw new Error('Writer API is unavailable on this device.');\n        }\n\n        const options = {\n          ...(writerOptions ?? {}),\n          monitor: (m: any) => {\n            m?.addEventListener?.('downloadprogress', (e: any) => {\n              if (typeof e.loaded === 'number') {\n                setDownloadProgress(Math.round(e.loaded * 100));\n              }\n            });\n          },\n        };\n\n        writerRef.current = await svcEnsureWriter(options as any);\n        return writerRef.current;\n      } catch (err) {\n        setAiError((err as Error).message);\n        onAIError?.(err as Error);\n        return null;\n      }\n    }, [isWriterSupported, writerOptions, onAIError]);\n\n    const startComposeStreaming = React.useCallback(async () => {\n      setAiError(null);\n      setResultText('');\n      setPhase('generating');\n      setIsLoading(true);\n\n      try {\n        const writer = writerRef.current ?? (await ensureWriter());\n        if (!writer) {\n          setIsLoading(false);\n          setPhase('prompt');\n          return;\n        }\n\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n\n        const stream = writer.writeStreaming(promptText, {\n          signal: abortRef.current.signal,\n          context: writerOptions?.sharedContext,\n        });\n\n        let acc = '';\n        for await (const chunk of stream) {\n          acc += chunk;\n          setResultText(acc);\n        }\n        setPhase('result');\n      } catch (err) {\n        if ((err as any)?.name === 'AbortError') {\n          // silently ignore aborts\n        } else {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          onAIError?.(err as Error);\n          setPhase('prompt');\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [ensureWriter, promptText, writerOptions, onAIError]);\n\n    const closeFeature = React.useCallback(() => {\n      abortRef.current?.abort();\n      abortRef.current = null;\n      setIsFeatureOpen(false);\n      setActiveFeature(null);\n      setPhase('prompt');\n      setPromptText('');\n      setResultText('');\n      setAiError(null);\n      setDownloadProgress(null);\n      setDetected(null);\n    }, []);\n\n    React.useEffect(() => {\n      return () => {\n        abortRef.current?.abort();\n        try { writerRef.current?.destroy?.(); } catch {}\n        suggestAbortRef.current?.abort();\n        if (suggestTimeoutRef.current) clearTimeout(suggestTimeoutRef.current);\n      };\n    }, []);\n\n    const openCompose = React.useCallback(() => {\n      setActiveFeature('compose');\n      setIsFeatureOpen(true);\n      setPhase('prompt');\n      setPromptText('');\n      setResultText('');\n      setAiError(null);\n    }, []);\n\n    const openImprove = React.useCallback(() => {\n      setActiveFeature('improve');\n      setIsFeatureOpen(true);\n      setPhase('prompt');\n      setResultText('');\n      setAiError(null);\n      setDownloadProgress(null);\n    }, []);\n\n    const openFixGrammar = React.useCallback(() => {\n      setActiveFeature('fix-grammar');\n      setIsFeatureOpen(true);\n      setPhase('generating');\n      setResultText('');\n      setAiError(null);\n      setDownloadProgress(null);\n      setDetected(null);\n    }, []);\n\n    const openTranslate = React.useCallback(() => {\n      setActiveFeature('translate');\n      setIsFeatureOpen(true);\n      setPhase('prompt');\n      setResultText('');\n      setAiError(null);\n      setDownloadProgress(null);\n      setDetected(null);\n      // Preselect first provided target if any\n      setSelectedTarget(translateTargets?.[0] || '');\n    }, [translateTargets]);\n\n    const startTranslate = React.useCallback(async () => {\n      setAiError(null);\n      setResultText('');\n      setPhase('generating');\n      setIsLoading(true);\n\n      try {\n        const text = textareaRef.current?.value || '';\n        if (!text.trim()) {\n          throw new Error('Please enter some text to translate.');\n        }\n        if (!selectedTarget) {\n          throw new Error('Please select a target language.');\n        }\n\n        // Detect source language and take the first\n        const detectedLangs = await detectLanguages(text);\n        setDetected(detectedLangs);\n        const sourceLanguage = (detectedLangs && detectedLangs.length > 0)\n          ? detectedLangs[0].detectedLanguage\n          : 'en';\n\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n\n        // Create Translator with monitor for download progress\n        const translator = await ensureTranslator({\n          sourceLanguage,\n          targetLanguage: selectedTarget,\n          monitor(m: any) {\n            try {\n              m.addEventListener('downloadprogress', (e: any) => {\n                if (typeof e.loaded === 'number') {\n                  setDownloadProgress(Math.round(e.loaded * 100));\n                }\n              });\n            } catch {}\n          },\n        } as any);\n\n        if (!translator) {\n          throw new Error('Failed to create translator. The language combination may not be supported by the Chrome Translator API.');\n        }\n\n        // Prefer non-streaming; if streaming exists, we could support\n        if (typeof translator.translateStreaming === 'function') {\n          const stream = translator.translateStreaming(text, { signal: abortRef.current.signal });\n          let acc = '';\n          for await (const chunk of stream) {\n            acc += chunk;\n            setResultText(acc);\n          }\n          setPhase('result');\n        } else {\n          const result = await translator.translate(text);\n          setResultText(result);\n          setPhase('result');\n        }\n      } catch (err) {\n        if ((err as any)?.name === 'AbortError') {\n          // ignore aborts\n        } else {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          setPhase('result');\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [selectedTarget]);\n\n    const startFixGrammar = React.useCallback(async () => {\n      setAiError(null);\n      setIsLoading(true);\n      try {\n        const text = textareaRef.current?.value || '';\n        if (!text.trim()) {\n          throw new Error('Please enter some text to fix grammar.');\n        }\n\n        // Detect languages first\n        const detectedLangs = await detectLanguages(text);\n        setDetected(detectedLangs);\n        const topLanguage = (detectedLangs && detectedLangs.length > 0)\n          ? detectedLangs[0].detectedLanguage\n          : 'en';\n\n        // Proofread with only the top detected language\n        const res = await proofreadOnce(text, {\n          expectedInputLanguages: [topLanguage],\n          onProgress: (p) => setDownloadProgress(p),\n        });\n        setResultText(res.corrected);\n        setPhase('result');\n      } catch (err) {\n        const msg = (err as Error).message;\n        setAiError(msg);\n        setPhase('result');\n      } finally {\n        setIsLoading(false);\n      }\n    }, []);\n\n    React.useEffect(() => {\n      if (isFeatureOpen && activeFeature === 'fix-grammar' && phase === 'generating' && !resultText) {\n        // kick off the flow once when dialog opens\n        startFixGrammar();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isFeatureOpen, activeFeature, phase]);\n\n    const acceptResult = React.useCallback(() => {\n      if (textareaRef.current) {\n        textareaRef.current.value = resultText;\n        // trigger input event for React forms\n        const event = new Event('input', { bubbles: true });\n        textareaRef.current.dispatchEvent(event);\n      }\n      onAccept?.(resultText);\n      closeFeature();\n    }, [resultText, onAccept, closeFeature]);\n\n    const regen = React.useCallback(() => {\n      setPhase('prompt');\n      setResultText('');\n      setAiError(null);\n    }, []);\n\n    const handleStop = React.useCallback(() => {\n      abortRef.current?.abort();\n      setIsLoading(false);\n      // Move to result phase to show Regenerate button immediately\n      setPhase('result');\n    }, []);\n\n    const featureIcon = React.useMemo(() => {\n      if (!activeFeature && (features?.length ?? 0) === 1) {\n        const f = features![0];\n        if (f === 'compose') return <Wand2 className=\"size-4\" />;\n        if (f === 'translate') return <Languages className=\"size-4\" />;\n        if (f === 'improve') return <Repeat2 className=\"size-4\" />;\n        if (f === 'fix-grammar') return <SpellCheck className=\"size-4\" />;\n      }\n      return <Wand2 className=\"size-4\" />;\n    }, [activeFeature, features]);\n\n\n    const handleSummarizeClick = React.useCallback(async () => {\n      const text = textareaRef.current?.value || '';\n      \n      if (!text.trim()) {\n        onSummaryError?.('Please enter some text to summarize.');\n        return;\n      }\n\n      // Check if Chrome AI is supported\n      if (!isSupported) {\n        onSummaryError?.('Chrome Summarizer API is not supported.');\n        return;\n      }\n\n      // Check availability\n      const availability = await checkSummarizerAvailability();\n      if (availability === 'unavailable') {\n        onSummaryError?.('Summarizer API is not available on this device. Please check hardware requirements.');\n        return;\n      }\n      if (availability === null) {\n        onSummaryError?.('Checking availability... Please try again in a moment.');\n        return;\n      }\n\n      setIsLoading(true);\n\n      try {\n        // Create summarizer with component-specific options\n        const summarizerOptions: SummarizerOptions = {\n          type: summaryType,\n          format: summaryFormat,\n          length: summaryLength,\n          sharedContext: sharedContext,\n        };\n\n        const summarizer = await ensureSummarizer(summarizerOptions);\n        if (!summarizer) {\n          setIsLoading(false);\n          return;\n        }\n\n        // Perform summarization\n        const context = sharedContext || 'This text is being summarized for better understanding.';\n        \n        if (enableStreaming) {\n          const stream = summarizer.summarizeStreaming(text, { context });\n          let result = '';\n          \n          for await (const chunk of stream) {\n            result += chunk;\n            onSummaryGenerated?.(result);\n          }\n          \n          onSummarize?.(text, result);\n          console.log(result);\n        } else {\n          const result = await summarizer.summarize(text, { context });\n          console.log(result);\n          onSummaryGenerated?.(result);\n          onSummarize?.(text, result);\n        }\n      } catch (err) {\n        const errorMsg = (err as Error).message;\n        onSummaryError?.(errorMsg);\n      } finally {\n        setIsLoading(false);\n      }\n    }, [\n      isSupported,\n      summaryType,\n      summaryFormat,\n      summaryLength,\n      sharedContext,\n      enableStreaming,\n      onSummarize,\n      onSummaryGenerated,\n      onSummaryError,\n    ]);\n\n    // ============ Rewriter API (Improve) ============\n    const [tone, setTone] = React.useState<'more-formal' | 'as-is' | 'more-casual'>('as-is');\n    const [lengthPref, setLengthPref] = React.useState<'shorter' | 'as-is' | 'longer'>('as-is');\n    const [formatPref, setFormatPref] = React.useState<'as-is' | 'markdown' | 'plain-text'>('plain-text');\n    const [contextText, setContextText] = React.useState('');\n\n    const ensureRewriter = React.useCallback(async () => {\n      try {\n        if (!isRewriterSupported) {\n          throw new Error('Chrome Rewriter API is not supported.');\n        }\n\n        const avail = await svcCheckRewriterAvailability();\n        if (avail === 'unavailable' || avail === null) {\n          throw new Error('Rewriter API is unavailable on this device.');\n        }\n\n        const options: RewriterOptions = {\n          tone,\n          length: lengthPref,\n          format: formatPref,\n          monitor: (m: any) => {\n            m?.addEventListener?.('downloadprogress', (e: any) => {\n              if (typeof e.loaded === 'number') {\n                setDownloadProgress(Math.round(e.loaded * 100));\n              }\n            });\n          },\n        };\n\n        rewriterRef.current = await svcEnsureRewriter(options as any);\n        return rewriterRef.current;\n      } catch (err) {\n        setAiError((err as Error).message);\n        onAIError?.(err as Error);\n        return null;\n      }\n    }, [isRewriterSupported, tone, lengthPref, formatPref, onAIError]);\n\n    const startImprove = React.useCallback(async () => {\n      setAiError(null);\n      setResultText('');\n      setPhase('generating');\n      setIsLoading(true);\n\n      try {\n        const text = textareaRef.current?.value || '';\n        if (!text.trim()) {\n          throw new Error('Please enter some text to improve.');\n        }\n\n        const rewriter = rewriterRef.current ?? (await ensureRewriter());\n        if (!rewriter) {\n          setIsLoading(false);\n          setPhase('prompt');\n          return;\n        }\n\n        abortRef.current?.abort();\n        abortRef.current = new AbortController();\n\n        if (typeof rewriter.rewriteStreaming === 'function') {\n          const stream = rewriter.rewriteStreaming(text, {\n            signal: abortRef.current.signal,\n            context: contextText || undefined,\n          });\n          let acc = '';\n          for await (const chunk of stream) {\n            acc += chunk;\n            setResultText(acc);\n          }\n          setPhase('result');\n        } else {\n          const result = await rewriter.rewrite(text, {\n            signal: abortRef.current.signal,\n            context: contextText || undefined,\n          });\n          setResultText(result);\n          setPhase('result');\n        }\n      } catch (err) {\n        if ((err as any)?.name === 'AbortError') {\n          // ignore aborts\n        } else {\n          const msg = (err as Error).message;\n          setAiError(msg);\n          onAIError?.(err as Error);\n          setPhase('prompt');\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [ensureRewriter, contextText, onAIError]);\n\n    // ============ Auto-suggest (Rewriter) ============\n    const defaultSuggestPrompt = 'Continue from the caret as an autocomplete. Do not change or repeat any existing user text before the caret. If you must return the full text, ensure it begins with the original text exactly and then adds only the natural continuation. No quotes or prefaces. Keep it coherent and concise (about 8–12 words).';\n\n    const autoSuggestActive = React.useMemo(() => {\n      return (typeof autoSuggestEnabled === 'boolean')\n        ? autoSuggestEnabled\n        : !!(features && features.includes('inline-suggest'));\n    }, [autoSuggestEnabled, features]);\n\n    const computeCaretPosition = React.useCallback(() => {\n      const ta = textareaRef.current;\n      const mirror = mirrorRef.current;\n      const marker = markerRef.current;\n      if (!ta || !mirror || !marker) return;\n\n      const cs = getComputedStyle(ta);\n      const mirrorStyle: Partial<CSSStyleDeclaration> = {\n        whiteSpace: 'pre-wrap',\n        wordWrap: 'break-word',\n      } as any;\n\n      // Mirror key typography and box metrics\n      mirror.style.position = 'absolute';\n      mirror.style.visibility = 'hidden';\n      mirror.style.zIndex = '-1';\n      mirror.style.whiteSpace = 'pre-wrap';\n      mirror.style.wordWrap = 'break-word';\n      mirror.style.top = '0px';\n      mirror.style.left = '0px';\n      mirror.style.width = ta.clientWidth + 'px';\n      mirror.style.fontFamily = cs.fontFamily;\n      mirror.style.fontSize = cs.fontSize;\n      mirror.style.fontWeight = cs.fontWeight as any;\n      mirror.style.letterSpacing = cs.letterSpacing;\n      mirror.style.lineHeight = cs.lineHeight;\n      mirror.style.padding = cs.padding;\n      mirror.style.border = cs.border;\n\n      const value = ta.value;\n      const caret = ta.selectionStart ?? value.length;\n      const before = value.substring(0, caret);\n      const after = value.substring(caret);\n\n      // Set mirror content with a marker at caret\n      const safeBefore = before.replace(/\\n/g, '\\n');\n      const safeAfter = after.replace(/\\n/g, '\\n');\n      mirror.innerText = '';\n      const beforeNode = document.createTextNode(safeBefore);\n      const afterNode = document.createTextNode(safeAfter);\n      mirror.appendChild(beforeNode);\n      mirror.appendChild(marker);\n      mirror.appendChild(afterNode);\n\n      const markerRect = marker.getBoundingClientRect();\n      const mirrorRect = mirror.getBoundingClientRect();\n      const top = markerRect.top - mirrorRect.top - ta.scrollTop;\n      const left = markerRect.left - mirrorRect.left - ta.scrollLeft;\n      const lineHeightNum = parseFloat(cs.lineHeight || '16') || ta.clientHeight / (ta.rows || 1) || 16;\n      setCaretPos({\n        top,\n        left,\n        lineHeight: lineHeightNum,\n        containerWidth: ta.clientWidth,\n        fontFamily: cs.fontFamily,\n        fontSize: cs.fontSize,\n        fontWeight: cs.fontWeight,\n        letterSpacing: cs.letterSpacing,\n        lineHeightCss: cs.lineHeight,\n      });\n    }, []);\n\n    const clearSuggestion = React.useCallback(() => {\n      setSuggestedText('');\n      setIsSuggesting(false);\n      suggestAbortRef.current?.abort();\n      suggestAbortRef.current = null;\n      if (suggestTimeoutRef.current) clearTimeout(suggestTimeoutRef.current);\n    }, []);\n\n    const maybeSuggest = React.useCallback(async () => {\n      if (!autoSuggestActive) return;\n      const ta = textareaRef.current;\n      if (!ta) return;\n\n      const value = ta.value;\n      const caret = ta.selectionStart ?? value.length;\n      const hasSelection = (ta.selectionEnd ?? caret) !== caret;\n      if (hasSelection) { clearSuggestion(); return; }\n\n      const prefix = value.substring(0, caret);\n      if (prefix.trim().length < 3) { clearSuggestion(); return; }\n\n      // Debounce: cancel prior\n      if (suggestTimeoutRef.current) clearTimeout(suggestTimeoutRef.current);\n      suggestTimeoutRef.current = setTimeout(async () => {\n        try {\n          setIsSuggesting(true);\n          suggestAbortRef.current?.abort();\n          suggestAbortRef.current = new AbortController();\n\n          // Ensure rewriter\n          const rewriter = rewriterRef.current ?? (await ensureRewriter());\n          if (!rewriter) { clearSuggestion(); return; }\n\n          // Compute caret position before request so overlay feels snappy\n          computeCaretPosition();\n\n          const context = (autoSuggestPrompt || defaultSuggestPrompt);\n          let completion: string = '';\n          if (typeof rewriter.rewrite === 'function') {\n            completion = await rewriter.rewrite(prefix, { signal: suggestAbortRef.current!.signal, context });\n          } else if (typeof rewriter.rewriteStreaming === 'function') {\n            let acc = '';\n            const stream = rewriter.rewriteStreaming(prefix, { signal: suggestAbortRef.current!.signal, context });\n            for await (const chunk of stream) { acc += chunk; if (acc.length >= autoSuggestMaxChars * 2) break; }\n            completion = acc;\n          }\n\n          // If model returned full text, extract continuation suffix.\n          let suggestion: string = '';\n          const input = prefix;\n          const out = (completion || '');\n          if (out.startsWith(input)) {\n            suggestion = out.slice(input.length);\n          } else {\n            // Fallback: find longest common prefix length and take the remainder\n            let i = 0;\n            const max = Math.min(input.length, out.length);\n            while (i < max && input.charCodeAt(i) === out.charCodeAt(i)) i++;\n            suggestion = out.slice(i);\n          }\n\n          // Post-process continuation: trim leading whitespace, enforce max chars and word boundary\n          suggestion = suggestion.replace(/^\\s+/, '');\n          if (suggestion.length > autoSuggestMaxChars) {\n            suggestion = suggestion.slice(0, autoSuggestMaxChars);\n            const lastSpace = suggestion.lastIndexOf(' ');\n            if (lastSpace > 8) suggestion = suggestion.slice(0, lastSpace);\n          }\n          // Avoid echoing punctuation-only or empty\n          if (!suggestion || /^(\\.|,|;|:|!|\\?|\\)|\\]|\\})+$/.test(suggestion)) {\n            clearSuggestion();\n            return;\n          }\n\n          setSuggestedText(suggestion);\n          setIsSuggesting(false);\n        } catch (err: any) {\n          if (err?.name !== 'AbortError') {\n            // silent fail\n          }\n          clearSuggestion();\n        }\n      }, autoSuggestDebounceMs);\n    }, [autoSuggestActive, autoSuggestDebounceMs, autoSuggestMaxChars, autoSuggestPrompt, ensureRewriter, computeCaretPosition, clearSuggestion]);\n\n    const acceptSuggestion = React.useCallback(() => {\n      const ta = textareaRef.current;\n      if (!ta || !suggestedText) return;\n      const start = ta.selectionStart ?? ta.value.length;\n      const end = ta.selectionEnd ?? start;\n      if (start !== end) return;\n      const before = ta.value.substring(0, start);\n      const after = ta.value.substring(end);\n      const next = before + suggestedText + after;\n      ta.value = next;\n      const newCaret = start + suggestedText.length;\n      ta.setSelectionRange(newCaret, newCaret);\n      // fire input event for React forms\n      const event = new Event('input', { bubbles: true });\n      ta.dispatchEvent(event);\n      setSuggestedText('');\n    }, [suggestedText]);\n\n    const onKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (e.key === 'ArrowRight' && suggestedText) {\n        e.preventDefault();\n        acceptSuggestion();\n        return;\n      }\n      if (e.key === 'Escape' && suggestedText) {\n        e.preventDefault();\n        clearSuggestion();\n        return;\n      }\n      // let outer handler run too\n      props.onKeyDown?.(e);\n    }, [suggestedText, acceptSuggestion, clearSuggestion, props]);\n\n    const onInput = React.useCallback((e: React.FormEvent<HTMLTextAreaElement>) => {\n      clearSuggestion();\n      maybeSuggest();\n      // also forward original onInput\n      props.onInput?.(e);\n    }, [maybeSuggest, clearSuggestion, props]);\n\n    const shouldShowButton =\n      buttonVisibility === 'ALWAYS' || (buttonVisibility === 'ON_FOCUS' && isFocused);\n\n    const defaultButtonContent = buttonContent ?? (\n      <Sparkles className=\"size-4\" />\n    );\n\n    const buttonContentWithLoading = isLoading ? (\n      <Spinner className=\"size-4\" />\n    ) : (\n      defaultButtonContent\n    );\n\n    const hasFeatureUI = Array.isArray(features) && features.length > 0;\n\n    return (\n      <div className={cn('relative', containerClassName)}>\n        <Textarea\n          ref={textareaRef}\n          className={className}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n          onKeyDown={onKeyDown}\n          onInput={onInput}\n          {...props}\n        />\n\n        {/* Hidden mirror to compute caret position */}\n        {autoSuggestActive && (\n          <div\n            ref={mirrorRef}\n            aria-hidden=\"true\"\n            className=\"pointer-events-none select-none\"\n            style={{\n              position: 'absolute',\n              visibility: 'hidden',\n              inset: 0,\n              overflow: 'hidden',\n            }}\n          >\n            <span ref={markerRef} />\n          </div>\n        )}\n\n        {/* Ghost suggestion overlay */}\n        {autoSuggestActive && suggestedText && (() => {\n          const baseLeft = Math.max(0, caretPos.left) + 2;\n          const baseTop = Math.max(0, caretPos.top);\n          let effLeft = baseLeft;\n          let effTop = baseTop;\n          let maxWidth = Math.max(0, (caretPos.containerWidth || 0) - baseLeft - 4);\n          if (maxWidth < 40) {\n            effLeft = 2;\n            effTop = baseTop + (caretPos.lineHeight || 0);\n            maxWidth = Math.max(0, (caretPos.containerWidth || 0) - 4);\n          }\n          return (\n            <div\n              className=\"pointer-events-none absolute\"\n              style={{\n                left: effLeft,\n                top: effTop,\n                maxWidth,\n                whiteSpace: 'pre-wrap',\n                wordBreak: 'break-word',\n                overflow: 'hidden',\n                fontFamily: caretPos.fontFamily,\n                fontSize: caretPos.fontSize,\n                fontWeight: caretPos.fontWeight as any,\n                letterSpacing: caretPos.letterSpacing,\n                lineHeight: caretPos.lineHeightCss,\n              }}\n            >\n              <span className=\"text-muted-foreground/60\">{suggestedText}</span>\n            </div>\n          );\n        })()}\n\n        {shouldShowButton && !hasFeatureUI && (\n          <Button\n            type=\"button\"\n            size=\"icon\"\n            variant=\"ghost\"\n            onClick={handleSummarizeClick}\n            disabled={isLoading}\n            className={cn(\n              'absolute right-2.5 top-2.5 h-7 w-7 rounded-md shadow-sm hover:bg-accent/80 transition-opacity z-10',\n              isLoading && 'cursor-wait',\n              buttonClassName\n            )}\n            aria-label={isLoading ? 'Summarizing...' : 'Summarize content'}\n          >\n            {buttonContentWithLoading}\n          </Button>\n        )}\n\n        {shouldShowButton && hasFeatureUI && (\n          features!.length === 1 ? (\n            <Button\n              type=\"button\"\n              size=\"icon\"\n              variant=\"ghost\"\n              onClick={() => {\n                if (features![0] === 'compose') {\n                  openCompose();\n                } else if (features![0] === 'improve') {\n                  openImprove();\n                } else if (features![0] === 'fix-grammar') {\n                  openFixGrammar();\n                }\n              }}\n              disabled={isLoading}\n              className={cn(\n                'absolute right-2.5 top-2.5 h-7 w-7 rounded-md shadow-sm hover:bg-accent/80 transition-opacity z-10',\n                isLoading && 'cursor-wait',\n                buttonClassName\n              )}\n              aria-label=\"AI actions\"\n            >\n              {isLoading ? <Spinner className=\"size-4\" /> : featureIcon}\n            </Button>\n          ) : (\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button\n                  type=\"button\"\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  disabled={isLoading}\n                  className={cn(\n                    'absolute right-2.5 top-2.5 h-7 w-7 rounded-md shadow-sm hover:bg-accent/80 transition-opacity z-10',\n                    isLoading && 'cursor-wait',\n                    buttonClassName\n                  )}\n                  aria-label=\"Choose AI action\"\n                >\n                  {isLoading ? <Spinner className=\"size-4\" /> : <Wand2 className=\"size-4\" />}\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align=\"end\" className=\"min-w-44\">\n                {features!.includes('compose') && (\n                  <DropdownMenuItem onClick={openCompose}>\n                    <Wand2 className=\"mr-2 h-4 w-4\" /> Compose\n                  </DropdownMenuItem>\n                )}\n                {features!.includes('improve') && (\n                  <DropdownMenuItem onClick={openImprove}>\n                    <Repeat2 className=\"mr-2 h-4 w-4\" /> Improve\n                  </DropdownMenuItem>\n                )}\n                {features!.includes('fix-grammar') && (\n                  <DropdownMenuItem onClick={openFixGrammar}>\n                    <SpellCheck className=\"mr-2 h-4 w-4\" /> Fix grammar\n                  </DropdownMenuItem>\n                )}\n                {features!.includes('translate') && (\n                  <DropdownMenuItem onClick={openTranslate}>\n                    <Languages className=\"mr-2 h-4 w-4\" /> Translate\n                  </DropdownMenuItem>\n                )}\n              </DropdownMenuContent>\n            </DropdownMenu>\n          )\n        )}\n\n        {/* Compose Modal */}\n        <Dialog open={isFeatureOpen && activeFeature === 'compose'} onOpenChange={(open) => { if (!open) closeFeature(); }}>\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Compose with AI</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">Model downloading… {downloadProgress}%</div>\n            )}\n\n            {phase === 'prompt' && (\n              <div className=\"space-y-3\">\n                <Input\n                  placeholder={placeholderPrompt || 'describe what you want'}\n                  value={promptText}\n                  onChange={(e) => setPromptText(e.target.value)}\n                />\n              </div>\n            )}\n\n              {phase === 'generating' && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Generating…\n                </div>\n                {resultText && (\n                  <Textarea value={resultText} readOnly className=\"min-h-[160px]\" />\n                )}\n              </div>\n            )}\n\n            {phase === 'result' && (\n              <div className=\"space-y-3\">\n                <Textarea value={resultText} readOnly className=\"min-h-[200px]\" />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === 'prompt' && (\n                <Button onClick={startComposeStreaming} disabled={!promptText.trim() || isLoading}>\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Generate\n                </Button>\n              )}\n              {phase === 'generating' && (\n                <Button variant=\"outline\" onClick={handleStop}>Stop</Button>\n              )}\n              {phase === 'result' && (\n                <>\n                  <Button variant=\"outline\" onClick={regen}>Regenerate</Button>\n                  {typeof resultText === 'string' && resultText.trim().length > 0 && (\n                    <Button onClick={acceptResult}>Accept</Button>\n                  )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Fix Grammar Modal */}\n        <Dialog open={isFeatureOpen && activeFeature === 'fix-grammar'} onOpenChange={(open) => { if (!open) closeFeature(); }}>\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Fix grammar</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {detected && detected.length > 0 && (\n              <div className=\"mb-2 text-xs text-muted-foreground\">\n                Detected: {detected.map((d) => d.detectedLanguage).join(', ')}\n              </div>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">Model downloading… {downloadProgress}%</div>\n            )}\n\n            {phase === 'generating' && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Fixing grammar…\n                </div>\n                {resultText && (\n                  <Textarea value={resultText} readOnly className=\"min-h-[160px]\" />\n                )}\n              </div>\n            )}\n\n            {phase === 'result' && (\n              <div className=\"space-y-3\">\n                <Textarea value={resultText} readOnly className=\"min-h-[200px]\" />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === 'generating' && (\n                <Button variant=\"outline\" onClick={handleStop}>Stop</Button>\n              )}\n              {phase === 'result' && (\n                <>\n                  <Button variant=\"outline\" onClick={() => {\n                    // regenerate with same detected languages\n                    setAiError(null);\n                    setPhase('generating');\n                    (async () => {\n                      try {\n                        const text = textareaRef.current?.value || '';\n                        const top = (detected && detected.length > 0) ? detected[0].detectedLanguage : 'en';\n                        const res = await proofreadOnce(text, {\n                          expectedInputLanguages: [top],\n                          onProgress: (p) => setDownloadProgress(p),\n                        });\n                        setResultText(res.corrected);\n                        setPhase('result');\n                      } catch (err) {\n                        const msg = (err as Error).message;\n                        setAiError(msg);\n                        setPhase('result');\n                      }\n                    })();\n                  }}>Regenerate</Button>\n                  {typeof resultText === 'string' && resultText.trim().length > 0 && (\n                    <Button onClick={acceptResult}>Accept</Button>\n                  )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Improve Modal */}\n        <Dialog open={isFeatureOpen && activeFeature === 'improve'} onOpenChange={(open) => { if (!open) closeFeature(); }}>\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Improve writing</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">Model downloading… {downloadProgress}%</div>\n            )}\n\n            {phase === 'prompt' && (\n              <div className=\"space-y-3\">\n                <div className=\"grid grid-cols-3 gap-2\">\n                  <Select value={tone} onValueChange={(v) => setTone(v as any)}>\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Tone\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"as-is\">Tone: As-is</SelectItem>\n                      <SelectItem value=\"more-formal\">Tone: More formal</SelectItem>\n                      <SelectItem value=\"more-casual\">Tone: More casual</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select value={lengthPref} onValueChange={(v) => setLengthPref(v as any)}>\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Length\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"as-is\">Length: As-is</SelectItem>\n                      <SelectItem value=\"shorter\">Length: Shorter</SelectItem>\n                      <SelectItem value=\"longer\">Length: Longer</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select value={formatPref} onValueChange={(v) => setFormatPref(v as any)}>\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Format\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"plain-text\">Format: Plain text</SelectItem>\n                      <SelectItem value=\"markdown\">Format: Markdown</SelectItem>\n                      <SelectItem value=\"as-is\">Format: As-is</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <Input\n                  placeholder=\"Optional context (e.g., audience or constraints)\"\n                  value={contextText}\n                  onChange={(e) => setContextText(e.target.value)}\n                />\n              </div>\n            )}\n\n            {phase === 'generating' && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Improving…\n                </div>\n                {resultText && (\n                  <Textarea value={resultText} readOnly className=\"min-h-[160px]\" />\n                )}\n              </div>\n            )}\n\n            {phase === 'result' && (\n              <div className=\"space-y-3\">\n                <Textarea value={resultText} readOnly className=\"min-h-[200px]\" />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === 'prompt' && (\n                <Button onClick={startImprove} disabled={isLoading}>\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Generate\n                </Button>\n              )}\n              {phase === 'generating' && (\n                <Button variant=\"outline\" onClick={handleStop}>Stop</Button>\n              )}\n              {phase === 'result' && (\n                <>\n                  <Button variant=\"outline\" onClick={regen}>Regenerate</Button>\n                  {typeof resultText === 'string' && resultText.trim().length > 0 && (\n                    <Button onClick={acceptResult}>Accept</Button>\n                  )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n\n        {/* Translate Modal */}\n        <Dialog open={isFeatureOpen && activeFeature === 'translate'} onOpenChange={(open) => { if (!open) closeFeature(); }}>\n          <DialogContent className=\"sm:max-w-lg\">\n            <DialogHeader>\n              <DialogTitle>Translate</DialogTitle>\n            </DialogHeader>\n\n            {aiError && (\n              <Alert variant=\"destructive\" className=\"mb-2\">\n                <AlertTitle>Error</AlertTitle>\n                <AlertDescription>{aiError}</AlertDescription>\n              </Alert>\n            )}\n\n            {detected && detected.length > 0 && (\n              <div className=\"mb-2 text-xs text-muted-foreground\">\n                Detected source: {detected[0].detectedLanguage}\n              </div>\n            )}\n\n            {downloadProgress !== null && downloadProgress < 100 && (\n              <div className=\"text-xs text-muted-foreground\">Model downloading… {downloadProgress}%</div>\n            )}\n\n            {phase === 'prompt' && (\n              <div className=\"space-y-3\">\n                <div className=\"grid grid-cols-1 gap-2\">\n                  <Select value={selectedTarget} onValueChange={(v) => setSelectedTarget(v)}>\n                    <SelectTrigger className=\"h-8\">\n                      <SelectValue placeholder=\"Select target language\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {translateTargets?.map((code: string) => (\n                        <SelectItem key={code} value={code}>\n                          {translateLanguageMap?.[code] || code}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n            )}\n\n            {phase === 'generating' && (\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Spinner className=\"size-4\" /> Translating…\n                </div>\n                {resultText && (\n                  <Textarea value={resultText} readOnly className=\"min-h-[160px]\" />\n                )}\n              </div>\n            )}\n\n            {phase === 'result' && (\n              <div className=\"space-y-3\">\n                <Textarea value={resultText} readOnly className=\"min-h-[200px]\" />\n              </div>\n            )}\n\n            <DialogFooter className=\"gap-2\">\n              {phase === 'prompt' && (\n                <Button onClick={startTranslate} disabled={!selectedTarget || isLoading}>\n                  {isLoading ? <Spinner className=\"mr-2 size-4\" /> : null}\n                  Translate\n                </Button>\n              )}\n              {phase === 'generating' && (\n                <Button variant=\"outline\" onClick={handleStop}>Stop</Button>\n              )}\n              {phase === 'result' && (\n                <>\n                  <Button variant=\"outline\" onClick={() => { setPhase('prompt'); setResultText(''); setAiError(null); }}>Regenerate</Button>\n                  {typeof resultText === 'string' && resultText.trim().length > 0 && (\n                    <Button onClick={acceptResult}>Accept</Button>\n                  )}\n                </>\n              )}\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      </div>\n    );\n  }\n);\n\nGenUITextarea.displayName = 'GenUITextarea';\n\n",
      "type": "registry:component"
    }
  ]
}