{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "genui-sonner",
  "type": "registry:block",
  "title": "AI Sonner",
  "description": "AI-powered toast notifications using Sonner with automatic text rewriting and tone customization.",
  "dependencies": [
    "sonner"
  ],
  "registryDependencies": [
    "sonner",
    "http://localhost:3000/r/genui-provider.json"
  ],
  "files": [
    {
      "path": "registry/new-york/gencn-ui/items/sonner/lib/genui-sonner.ts",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { toast, type ExternalToast } from \"sonner\";\nimport type {\n  RewriterOptions,\n  RewriteOptions,\n} from \"@/registry/new-york/gencn-ui/items/shared/genui-types\";\n\nexport type RewriterAvailability =\n  | \"available\"\n  | \"downloadable\"\n  | \"unavailable\"\n  | null;\n\nexport function isRewriterSupported(): boolean {\n  return \"Rewriter\" in self;\n}\n\nexport async function checkRewriterAvailability(): Promise<RewriterAvailability> {\n  if (!isRewriterSupported()) return null;\n  try {\n    const status = await (self as any).Rewriter.availability();\n    return status as RewriterAvailability;\n  } catch {\n    return null;\n  }\n}\n\nexport async function ensureRewriter(\n  options?: RewriterOptions & { onProgress?: (percent: number) => void }\n): Promise<any> {\n  if (!isRewriterSupported()) {\n    throw new Error(\"Chrome Rewriter API is not supported.\");\n  }\n\n  const availability = await checkRewriterAvailability();\n  if (availability === \"unavailable\" || availability === null) {\n    throw new Error(\"Rewriter API is unavailable on this device.\");\n  }\n\n  const createOptions: any = {\n    ...options,\n    monitor: (monitor: any) => {\n      if (options?.monitor) {\n        options.monitor(monitor);\n      }\n      try {\n        monitor?.addEventListener?.(\"downloadprogress\", (e: any) => {\n          if (typeof e.loaded === \"number\") {\n            options?.onProgress?.(Math.round(e.loaded * 100));\n          }\n        });\n      } catch {}\n    },\n  };\n\n  const rewriter = await (self as any).Rewriter.create(createOptions);\n  return rewriter;\n}\n\nexport async function rewriteOnce(\n  text: string,\n  options?: (RewriterOptions & { onProgress?: (percent: number) => void }) &\n    RewriteOptions\n): Promise<string> {\n  if (!text.trim()) {\n    throw new Error(\"Please enter some text to improve.\");\n  }\n\n  const rewriter = await ensureRewriter(options);\n  const result = await rewriter.rewrite(text, {\n    context: options?.context,\n    signal: options?.signal,\n  });\n  return result as string;\n}\n\nexport async function* rewriteStreaming(\n  text: string,\n  options?: (RewriterOptions & {\n    signal?: AbortSignal;\n    onProgress?: (percent: number) => void;\n  }) &\n    RewriteOptions\n): AsyncGenerator<string> {\n  if (!text.trim()) {\n    throw new Error(\"Please enter some text to improve.\");\n  }\n\n  const rewriter = await ensureRewriter(options);\n  const stream = rewriter.rewriteStreaming(text, {\n    context: options?.context,\n    signal: options?.signal,\n  });\n  let acc = \"\";\n  for await (const chunk of stream) {\n    acc += chunk;\n    yield acc as string;\n  }\n}\n\nexport type AITone =\n  | \"friendly\"\n  | \"funny\"\n  | \"sarcastic\"\n  | \"rude\"\n  | \"dramatic\"\n  | \"professional\"\n  | \"cheerful\"\n  | \"empathetic\"\n  | \"concise\"\n  | \"motivational\";\n\nexport const GenUISONNER_TONES: AITone[] = [\n  \"friendly\",\n  \"funny\",\n  \"sarcastic\",\n  \"rude\",\n  \"dramatic\",\n  \"professional\",\n  \"cheerful\",\n  \"empathetic\",\n  \"concise\",\n  \"motivational\",\n];\n\nexport type GenUISONNEROptions = ExternalToast & {\n  tone?: AITone;\n  maxLength?: number;\n  retryOnFail?: boolean;\n};\n\nasync function rewriteIfString(\n  input: React.ReactNode,\n  tone?: AITone,\n  maxLength?: number,\n  retryOnFail: boolean = true\n): Promise<React.ReactNode> {\n  if (typeof input !== \"string\") return input;\n\n  const text = input as string;\n  const toneInstruction = tone\n    ? `Rephrase the following text in a ${tone} tone while preserving intent.`\n    : \"Rephrase the following text to improve clarity while preserving intent.\";\n\n  const lengthInstruction =\n    typeof maxLength === \"number\" && maxLength > 0\n      ? ` Keep it under ${maxLength} characters.`\n      : \"\";\n\n  const context = `${toneInstruction}${lengthInstruction} Respond with only the rewritten text, no quotes.`;\n\n  try {\n    const rewritten = await rewriteOnce(text, { context });\n    return rewritten || text;\n  } catch (err) {\n    if (retryOnFail) return text;\n    throw err;\n  }\n}\n\nfunction isExternalToastOptions(\n  opts?: ExternalToast | GenUISONNEROptions\n): opts is GenUISONNEROptions {\n  return !!opts;\n}\n\nexport async function genUIToast(\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast(rewritten, options);\n}\n\ngenUIToast.success = async function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast.success(rewritten, options);\n};\n\ngenUIToast.error = async function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast.error(rewritten, options);\n};\n\ngenUIToast.info = async function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast.info(rewritten, options);\n};\n\ngenUIToast.warning = async function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast.warning(rewritten, options);\n};\n\ngenUIToast.message = async function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  const rewritten = await rewriteIfString(\n    message,\n    options?.tone,\n    options?.maxLength,\n    options?.retryOnFail !== false\n  );\n  return toast.message(rewritten as any, options as any);\n};\n\ngenUIToast.loading = function (\n  message: React.ReactNode,\n  options?: GenUISONNEROptions\n) {\n  // For loading, show immediately; do not wait for rewriting to avoid UX delay.\n  return toast.loading(message, options);\n};\n\ngenUIToast.custom = function (\n  renderer: Parameters<typeof toast.custom>[0],\n  options?: ExternalToast\n) {\n  return toast.custom(renderer, options);\n};\n\ngenUIToast.dismiss = function (toastId?: number | string) {\n  return toast.dismiss(toastId as any);\n};\n\ngenUIToast.promise = async function <T>(\n  promise: Promise<T>,\n  cfg: {\n    loading: React.ReactNode;\n    success: React.ReactNode | ((value: T) => React.ReactNode);\n    error: React.ReactNode | ((error: any) => React.ReactNode);\n    tone?: AITone;\n    maxLength?: number;\n    retryOnFail?: boolean;\n  },\n  options?: GenUISONNEROptions\n) {\n  // Show loading immediately (without waiting for rewrite)\n  const id = toast.loading(cfg.loading, options);\n\n  try {\n    const value = await promise;\n    const successContent =\n      typeof cfg.success === \"function\" ? cfg.success(value) : cfg.success;\n    const rewritten = await rewriteIfString(\n      successContent,\n      cfg.tone ?? options?.tone,\n      cfg.maxLength ?? options?.maxLength,\n      (cfg.retryOnFail ?? options?.retryOnFail) !== false\n    );\n    return toast.success(rewritten, { ...options, id });\n  } catch (error) {\n    const errorContent =\n      typeof cfg.error === \"function\" ? cfg.error(error) : cfg.error;\n    const rewritten = await rewriteIfString(\n      errorContent,\n      cfg.tone ?? options?.tone,\n      cfg.maxLength ?? options?.maxLength,\n      (cfg.retryOnFail ?? options?.retryOnFail) !== false\n    );\n    return toast.error(rewritten, { ...options, id });\n  }\n};\n\n// Re-export Toaster passthrough for convenience if consumers need to render it.\nexport { Toaster } from \"sonner\";\n\nexport type GenUIToastType = typeof genUIToast;\n",
      "type": "registry:lib"
    }
  ]
}